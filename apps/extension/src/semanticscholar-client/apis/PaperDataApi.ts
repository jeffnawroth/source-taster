/* tslint:disable */
/* eslint-disable */
/**
 * Academic Graph API
 * Fetch paper and author data from the Semantic Scholar Academic Graph (S2AG).         <br><br>         Some things to note:         <ul>         <li>If you are using an API key, it must be set in the header <code>x-api-key</code> (case-sensitive).</li>         <li>We have two different IDs for a single paper:           <ul>             <li><code>paperId</code> - string - The primary way to identify papers when using our website or this API</li>             <li><code>corpusId</code> - int64 - A second way to identify papers. Our datasets use corpusId when pointing to papers.</li>           </ul>         </li>         <li>Other useful resources<ul>         <li><a href=\"https://www.semanticscholar.org/product/api\">Overview</a></li>         <li><a href=\"https://github.com/allenai/s2-folks/\">allenai/s2-folks</a></li>         <li><a href=\"https://github.com/allenai/s2-folks/blob/main/FAQ.md\">FAQ</a> in allenai/s2folks</li>         </ul></li>         
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AuthorBatch,
  CitationBatch,
  Error400,
  Error404,
  FullPaper,
  PaperAutocomplete,
  PaperBatch,
  PaperBulkSearchBatch,
  PaperMatch,
  PaperRelevanceSearchBatch,
  ReferenceBatch,
} from '../models/index';
import {
    AuthorBatchFromJSON,
    AuthorBatchToJSON,
    CitationBatchFromJSON,
    CitationBatchToJSON,
    Error400FromJSON,
    Error400ToJSON,
    Error404FromJSON,
    Error404ToJSON,
    FullPaperFromJSON,
    FullPaperToJSON,
    PaperAutocompleteFromJSON,
    PaperAutocompleteToJSON,
    PaperBatchFromJSON,
    PaperBatchToJSON,
    PaperBulkSearchBatchFromJSON,
    PaperBulkSearchBatchToJSON,
    PaperMatchFromJSON,
    PaperMatchToJSON,
    PaperRelevanceSearchBatchFromJSON,
    PaperRelevanceSearchBatchToJSON,
    ReferenceBatchFromJSON,
    ReferenceBatchToJSON,
} from '../models/index';

export interface GetGraphGetPaperRequest {
    paperId: string;
    fields?: string;
}

export interface GetGraphGetPaperAuthorsRequest {
    paperId: string;
    offset?: number;
    limit?: number;
    fields?: string;
}

export interface GetGraphGetPaperAutocompleteRequest {
    query: string;
}

export interface GetGraphGetPaperCitationsRequest {
    paperId: string;
    offset?: number;
    limit?: number;
    fields?: string;
}

export interface GetGraphGetPaperReferencesRequest {
    paperId: string;
    offset?: number;
    limit?: number;
    fields?: string;
}

export interface GetGraphPaperBulkSearchRequest {
    query: string;
    token?: string;
    fields?: string;
    sort?: string;
    publicationTypes?: string;
    openAccessPdf?: string;
    minCitationCount?: string;
    publicationDateOrYear?: string;
    year?: string;
    venue?: string;
    fieldsOfStudy?: string;
}

export interface GetGraphPaperRelevanceSearchRequest {
    query: string;
    fields?: string;
    publicationTypes?: string;
    openAccessPdf?: string;
    minCitationCount?: string;
    publicationDateOrYear?: string;
    year?: string;
    venue?: string;
    fieldsOfStudy?: string;
    offset?: number;
    limit?: number;
}

export interface GetGraphPaperTitleSearchRequest {
    query: string;
    fields?: string;
    publicationTypes?: string;
    openAccessPdf?: string;
    minCitationCount?: string;
    publicationDateOrYear?: string;
    year?: string;
    venue?: string;
    fieldsOfStudy?: string;
}

export interface PostGraphGetPapersRequest {
    payload: PaperBatch;
    fields?: string;
}

/**
 * 
 */
export class PaperDataApi extends runtime.BaseAPI {

    /**
     * Examples: <ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b</code></li>     <ul>         <li>Returns a paper with its paperId and title.  </li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b?fields=url,year,authors</code></li>     <ul>         <li>Returns the paper\'s paperId, url, year, and list of authors.  </li>         <li>Each author has authorId and name.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b?fields=citations.authors</code></li>     <ul>         <li>Returns the paper\'s paperId and list of citations.  </li>         <li>Each citation has its paperId plus its list of authors.</li>         <li>Each author has their 2 always included fields of authorId and name.</li>     </ul>     <br>     Limitations:     <ul>         <li>Can only return up to 10 MB of data at a time.</li>     </ul> </ul>
     * Details about a paper
     */
    async getGraphGetPaperRaw(requestParameters: GetGraphGetPaperRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullPaper>> {
        if (requestParameters['paperId'] == null) {
            throw new runtime.RequiredError(
                'paperId',
                'Required parameter "paperId" was null or undefined when calling getGraphGetPaper().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/paper/{paper_id}`.replace(`{${"paper_id"}}`, encodeURIComponent(String(requestParameters['paperId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullPaperFromJSON(jsonValue));
    }

    /**
     * Examples: <ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b</code></li>     <ul>         <li>Returns a paper with its paperId and title.  </li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b?fields=url,year,authors</code></li>     <ul>         <li>Returns the paper\'s paperId, url, year, and list of authors.  </li>         <li>Each author has authorId and name.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b?fields=citations.authors</code></li>     <ul>         <li>Returns the paper\'s paperId and list of citations.  </li>         <li>Each citation has its paperId plus its list of authors.</li>         <li>Each author has their 2 always included fields of authorId and name.</li>     </ul>     <br>     Limitations:     <ul>         <li>Can only return up to 10 MB of data at a time.</li>     </ul> </ul>
     * Details about a paper
     */
    async getGraphGetPaper(requestParameters: GetGraphGetPaperRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullPaper> {
        const response = await this.getGraphGetPaperRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Examples: <ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/authors</code></li>     <ul>         <li>Returns with offset=0, and data is a list of all 3 authors.</li>         <li>Each author has their authorId and name</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/authors?fields=affiliations,papers&limit=2</code></li>     <ul>         <li>Returns with offset=0, next=2, and data is a list of 2 authors.</li>         <li>Each author has their authorId, affiliations, and list of papers.</li>         <li>Each paper has its paperId and title.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/authors?fields=url,papers.year,papers.authors&offset=2</code></li>     <ul>         <li>Returns with offset=2, and data is a list containing the last author.</li>         <li>This author has their authorId, url, and list of papers.</li>         <li>Each paper has its paperId, year, and list of authors.</li>         <li>In that list of authors, each author has their authorId and name.</li>     </ul> </ul>
     * Details about a paper\'s authors
     */
    async getGraphGetPaperAuthorsRaw(requestParameters: GetGraphGetPaperAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorBatch>> {
        if (requestParameters['paperId'] == null) {
            throw new runtime.RequiredError(
                'paperId',
                'Required parameter "paperId" was null or undefined when calling getGraphGetPaperAuthors().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/paper/{paper_id}/authors`.replace(`{${"paper_id"}}`, encodeURIComponent(String(requestParameters['paperId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorBatchFromJSON(jsonValue));
    }

    /**
     * Examples: <ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/authors</code></li>     <ul>         <li>Returns with offset=0, and data is a list of all 3 authors.</li>         <li>Each author has their authorId and name</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/authors?fields=affiliations,papers&limit=2</code></li>     <ul>         <li>Returns with offset=0, next=2, and data is a list of 2 authors.</li>         <li>Each author has their authorId, affiliations, and list of papers.</li>         <li>Each paper has its paperId and title.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/authors?fields=url,papers.year,papers.authors&offset=2</code></li>     <ul>         <li>Returns with offset=2, and data is a list containing the last author.</li>         <li>This author has their authorId, url, and list of papers.</li>         <li>Each paper has its paperId, year, and list of authors.</li>         <li>In that list of authors, each author has their authorId and name.</li>     </ul> </ul>
     * Details about a paper\'s authors
     */
    async getGraphGetPaperAuthors(requestParameters: GetGraphGetPaperAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorBatch> {
        const response = await this.getGraphGetPaperAuthorsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * To support interactive query-completion, return minimal information about papers matching a partial query  Example: <code>https://api.semanticscholar.org/graph/v1/paper/autocomplete?query=semanti</code>
     * Suggest paper query completions
     */
    async getGraphGetPaperAutocompleteRaw(requestParameters: GetGraphGetPaperAutocompleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaperAutocomplete>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling getGraphGetPaperAutocomplete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/paper/autocomplete`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaperAutocompleteFromJSON(jsonValue));
    }

    /**
     * To support interactive query-completion, return minimal information about papers matching a partial query  Example: <code>https://api.semanticscholar.org/graph/v1/paper/autocomplete?query=semanti</code>
     * Suggest paper query completions
     */
    async getGraphGetPaperAutocomplete(requestParameters: GetGraphGetPaperAutocompleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaperAutocomplete> {
        const response = await this.getGraphGetPaperAutocompleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch details about the papers the cite this paper (i.e. papers in whose bibliography this paper appears) <br><br> Examples: <ul>     <li>Let\'s suppose that the paper in the examples below has 1600 citations...</li>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/citations</code></li>     <ul>         <li>Returns with offset=0, next=100, and data is a list of 100 citations.</li>         <li>Each citation has a citingPaper which contains its paperId and title.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/citations?fields=contexts,intents,isInfluential,abstract&offset=200&limit=10</code></li>     <ul>         <li>Returns with offset=200, next=210, and data is a list of 10 citations.</li>         <li>Each citation has contexts, intents, isInfluential, and a citingPaper which contains its paperId and abstract.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/citations?fields=authors&offset=1500&limit=500</code></li>     <ul>         <li>Returns with offset=1500, and data is a list of the last 100 citations.</li>         <li>Each citation has a citingPaper which contains its paperId plus a list of authors</li>         <li>The authors under each citingPaper has their authorId and name.</li>     </ul> </ul>
     * Details about a paper\'s citations
     */
    async getGraphGetPaperCitationsRaw(requestParameters: GetGraphGetPaperCitationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CitationBatch>> {
        if (requestParameters['paperId'] == null) {
            throw new runtime.RequiredError(
                'paperId',
                'Required parameter "paperId" was null or undefined when calling getGraphGetPaperCitations().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/paper/{paper_id}/citations`.replace(`{${"paper_id"}}`, encodeURIComponent(String(requestParameters['paperId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CitationBatchFromJSON(jsonValue));
    }

    /**
     * Fetch details about the papers the cite this paper (i.e. papers in whose bibliography this paper appears) <br><br> Examples: <ul>     <li>Let\'s suppose that the paper in the examples below has 1600 citations...</li>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/citations</code></li>     <ul>         <li>Returns with offset=0, next=100, and data is a list of 100 citations.</li>         <li>Each citation has a citingPaper which contains its paperId and title.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/citations?fields=contexts,intents,isInfluential,abstract&offset=200&limit=10</code></li>     <ul>         <li>Returns with offset=200, next=210, and data is a list of 10 citations.</li>         <li>Each citation has contexts, intents, isInfluential, and a citingPaper which contains its paperId and abstract.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/citations?fields=authors&offset=1500&limit=500</code></li>     <ul>         <li>Returns with offset=1500, and data is a list of the last 100 citations.</li>         <li>Each citation has a citingPaper which contains its paperId plus a list of authors</li>         <li>The authors under each citingPaper has their authorId and name.</li>     </ul> </ul>
     * Details about a paper\'s citations
     */
    async getGraphGetPaperCitations(requestParameters: GetGraphGetPaperCitationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CitationBatch> {
        const response = await this.getGraphGetPaperCitationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch details about the papers cited by this paper (i.e. appearing in this paper\'s bibliography) <br><br> Examples: <ul>     <li>Let\'s suppose that the paper in the examples below has 1600 references...</li>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/references</code></li>     <ul>         <li>Returns with offset=0, next=100, and data is a list of 100 references.</li>         <li>Each reference has a citedPaper which contains its paperId and title.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/references?fields=contexts,intents,isInfluential,abstract&offset=200&limit=10</code></li>     <ul>         <li>Returns with offset=200, next=210, and data is a list of 10 references.</li>         <li>Each reference has contexts, intents, isInfluential, and a citedPaper which contains its paperId and abstract.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/references?fields=authors&offset=1500&limit=500</code></li>     <ul>         <li>Returns with offset=1500, and data is a list of the last 100 references.</li>         <li>Each reference has a citedPaper which contains its paperId plus a list of authors</li>         <li>The authors under each citedPaper has their authorId and name.</li>     </ul> </ul>
     * Details about a paper\'s references
     */
    async getGraphGetPaperReferencesRaw(requestParameters: GetGraphGetPaperReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReferenceBatch>> {
        if (requestParameters['paperId'] == null) {
            throw new runtime.RequiredError(
                'paperId',
                'Required parameter "paperId" was null or undefined when calling getGraphGetPaperReferences().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/paper/{paper_id}/references`.replace(`{${"paper_id"}}`, encodeURIComponent(String(requestParameters['paperId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferenceBatchFromJSON(jsonValue));
    }

    /**
     * Fetch details about the papers cited by this paper (i.e. appearing in this paper\'s bibliography) <br><br> Examples: <ul>     <li>Let\'s suppose that the paper in the examples below has 1600 references...</li>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/references</code></li>     <ul>         <li>Returns with offset=0, next=100, and data is a list of 100 references.</li>         <li>Each reference has a citedPaper which contains its paperId and title.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/references?fields=contexts,intents,isInfluential,abstract&offset=200&limit=10</code></li>     <ul>         <li>Returns with offset=200, next=210, and data is a list of 10 references.</li>         <li>Each reference has contexts, intents, isInfluential, and a citedPaper which contains its paperId and abstract.</li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b/references?fields=authors&offset=1500&limit=500</code></li>     <ul>         <li>Returns with offset=1500, and data is a list of the last 100 references.</li>         <li>Each reference has a citedPaper which contains its paperId plus a list of authors</li>         <li>The authors under each citedPaper has their authorId and name.</li>     </ul> </ul>
     * Details about a paper\'s references
     */
    async getGraphGetPaperReferences(requestParameters: GetGraphGetPaperReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReferenceBatch> {
        const response = await this.getGraphGetPaperReferencesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Behaves similarly to <code>/paper/search</code>, but is intended for bulk retrieval of basic paper data without search relevance: <ul> <li>Text query is optional and supports boolean logic for document matching.</li> <li>Papers can be filtered using various criteria.</li> <li>Up to 1,000 papers will be returned in each call.</li> <li>If there are more matching papers, a continuation \"token\" will be present.</li> <li>The query can be repeated with the token param added to efficiently continue fetching matching papers.</li> </ul> <br> Returns a structure with an estimated total matches, batch of matching papers, and a continuation token if more results are available. <br> Limitations: <ul> <li>Nested paper data, such as citations, references, etc, is not available via this method.</li> <li>Up to 10,000,000 papers can be fetched via this method. For larger needs, please use the <a href=\"datasets/\">Datasets API</a> to retrieve full copies of the corpus.</li> </ul>
     * Paper bulk search
     */
    async getGraphPaperBulkSearchRaw(requestParameters: GetGraphPaperBulkSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaperBulkSearchBatch>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling getGraphPaperBulkSearch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['token'] != null) {
            queryParameters['token'] = requestParameters['token'];
        }

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['publicationTypes'] != null) {
            queryParameters['publicationTypes'] = requestParameters['publicationTypes'];
        }

        if (requestParameters['openAccessPdf'] != null) {
            queryParameters['openAccessPdf'] = requestParameters['openAccessPdf'];
        }

        if (requestParameters['minCitationCount'] != null) {
            queryParameters['minCitationCount'] = requestParameters['minCitationCount'];
        }

        if (requestParameters['publicationDateOrYear'] != null) {
            queryParameters['publicationDateOrYear'] = requestParameters['publicationDateOrYear'];
        }

        if (requestParameters['year'] != null) {
            queryParameters['year'] = requestParameters['year'];
        }

        if (requestParameters['venue'] != null) {
            queryParameters['venue'] = requestParameters['venue'];
        }

        if (requestParameters['fieldsOfStudy'] != null) {
            queryParameters['fieldsOfStudy'] = requestParameters['fieldsOfStudy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/paper/search/bulk`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaperBulkSearchBatchFromJSON(jsonValue));
    }

    /**
     * Behaves similarly to <code>/paper/search</code>, but is intended for bulk retrieval of basic paper data without search relevance: <ul> <li>Text query is optional and supports boolean logic for document matching.</li> <li>Papers can be filtered using various criteria.</li> <li>Up to 1,000 papers will be returned in each call.</li> <li>If there are more matching papers, a continuation \"token\" will be present.</li> <li>The query can be repeated with the token param added to efficiently continue fetching matching papers.</li> </ul> <br> Returns a structure with an estimated total matches, batch of matching papers, and a continuation token if more results are available. <br> Limitations: <ul> <li>Nested paper data, such as citations, references, etc, is not available via this method.</li> <li>Up to 10,000,000 papers can be fetched via this method. For larger needs, please use the <a href=\"datasets/\">Datasets API</a> to retrieve full copies of the corpus.</li> </ul>
     * Paper bulk search
     */
    async getGraphPaperBulkSearch(requestParameters: GetGraphPaperBulkSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaperBulkSearchBatch> {
        const response = await this.getGraphPaperBulkSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Examples: <ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search?query=covid+vaccination&offset=100&limit=3</code></li>   <ul>     <li>Returns with total=576278, offset=100, next=103, and data is a list of 3 papers.</li>     <li>Each paper has its paperId and title.  </li>   </ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search?query=covid&fields=url,abstract,authors</code></li>   <ul>     <li>Returns with total=639637, offset=0, next=100, and data is a list of 100 papers.</li>     <li>Each paper has paperId, url, abstract, and a list of authors.</li>     <li>Each author under that list has authorId and name.</li>   </ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search?query=totalGarbageNonsense</code></li>   <ul>     <li>Returns with total=0, offset=0, and data is a list of 0 papers.</li>   </ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search?query=covid&year=2020-2023&openAccessPdf&fieldsOfStudy=Physics,Philosophy&fields=title,year,authors</code></li>   <ul>     <li>Returns with total=8471, offset=0, next=10, and data is a list of 10 papers. </li>     <li>Filters to include only papers published between 2020-2023.</li>     <li>Filters to include only papers with open access PDFs.</li>     <li>Filters to include only papers that have a field of study either matching Physics or Philosophy.</li>     <li>Each paper has the fields paperId, title, year, and authors.</li>   </ul>   <br>     Limitations:     <ul>         <li>Can only return up to 1,000 relevance-ranked results. For larger queries, see \"/search/bulk\" or the Datasets API.</li>         <li>Can only return up to 10 MB of data at a time.</li>     </ul> </ul>
     * Paper relevance search
     */
    async getGraphPaperRelevanceSearchRaw(requestParameters: GetGraphPaperRelevanceSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaperRelevanceSearchBatch>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling getGraphPaperRelevanceSearch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        if (requestParameters['publicationTypes'] != null) {
            queryParameters['publicationTypes'] = requestParameters['publicationTypes'];
        }

        if (requestParameters['openAccessPdf'] != null) {
            queryParameters['openAccessPdf'] = requestParameters['openAccessPdf'];
        }

        if (requestParameters['minCitationCount'] != null) {
            queryParameters['minCitationCount'] = requestParameters['minCitationCount'];
        }

        if (requestParameters['publicationDateOrYear'] != null) {
            queryParameters['publicationDateOrYear'] = requestParameters['publicationDateOrYear'];
        }

        if (requestParameters['year'] != null) {
            queryParameters['year'] = requestParameters['year'];
        }

        if (requestParameters['venue'] != null) {
            queryParameters['venue'] = requestParameters['venue'];
        }

        if (requestParameters['fieldsOfStudy'] != null) {
            queryParameters['fieldsOfStudy'] = requestParameters['fieldsOfStudy'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/paper/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaperRelevanceSearchBatchFromJSON(jsonValue));
    }

    /**
     * Examples: <ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search?query=covid+vaccination&offset=100&limit=3</code></li>   <ul>     <li>Returns with total=576278, offset=100, next=103, and data is a list of 3 papers.</li>     <li>Each paper has its paperId and title.  </li>   </ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search?query=covid&fields=url,abstract,authors</code></li>   <ul>     <li>Returns with total=639637, offset=0, next=100, and data is a list of 100 papers.</li>     <li>Each paper has paperId, url, abstract, and a list of authors.</li>     <li>Each author under that list has authorId and name.</li>   </ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search?query=totalGarbageNonsense</code></li>   <ul>     <li>Returns with total=0, offset=0, and data is a list of 0 papers.</li>   </ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search?query=covid&year=2020-2023&openAccessPdf&fieldsOfStudy=Physics,Philosophy&fields=title,year,authors</code></li>   <ul>     <li>Returns with total=8471, offset=0, next=10, and data is a list of 10 papers. </li>     <li>Filters to include only papers published between 2020-2023.</li>     <li>Filters to include only papers with open access PDFs.</li>     <li>Filters to include only papers that have a field of study either matching Physics or Philosophy.</li>     <li>Each paper has the fields paperId, title, year, and authors.</li>   </ul>   <br>     Limitations:     <ul>         <li>Can only return up to 1,000 relevance-ranked results. For larger queries, see \"/search/bulk\" or the Datasets API.</li>         <li>Can only return up to 10 MB of data at a time.</li>     </ul> </ul>
     * Paper relevance search
     */
    async getGraphPaperRelevanceSearch(requestParameters: GetGraphPaperRelevanceSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaperRelevanceSearchBatch> {
        const response = await this.getGraphPaperRelevanceSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Behaves similarly to <code>/paper/search</code>, but is intended for retrieval of a single paper based on closest title match to given query. Examples: <ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search/match?query=Construction of the Literature Graph in Semantic Scholar</code></li>   <ul>     <li>Returns a single paper that is the closest title match.</li>     <li>Each paper has its paperId, title, and matchScore as well as any other requested fields.</li>   </ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search/match?query=totalGarbageNonsense</code></li>   <ul>     <li>Returns with a 404 error and a \"Title match not found\" message.</li>   </ul> </ul>   <br>     Limitations:     <ul>         <li>Will only return the single highest match result.</li>     </ul> </ul>
     * Paper title search
     */
    async getGraphPaperTitleSearchRaw(requestParameters: GetGraphPaperTitleSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaperMatch>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling getGraphPaperTitleSearch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        if (requestParameters['publicationTypes'] != null) {
            queryParameters['publicationTypes'] = requestParameters['publicationTypes'];
        }

        if (requestParameters['openAccessPdf'] != null) {
            queryParameters['openAccessPdf'] = requestParameters['openAccessPdf'];
        }

        if (requestParameters['minCitationCount'] != null) {
            queryParameters['minCitationCount'] = requestParameters['minCitationCount'];
        }

        if (requestParameters['publicationDateOrYear'] != null) {
            queryParameters['publicationDateOrYear'] = requestParameters['publicationDateOrYear'];
        }

        if (requestParameters['year'] != null) {
            queryParameters['year'] = requestParameters['year'];
        }

        if (requestParameters['venue'] != null) {
            queryParameters['venue'] = requestParameters['venue'];
        }

        if (requestParameters['fieldsOfStudy'] != null) {
            queryParameters['fieldsOfStudy'] = requestParameters['fieldsOfStudy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/paper/search/match`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaperMatchFromJSON(jsonValue));
    }

    /**
     * Behaves similarly to <code>/paper/search</code>, but is intended for retrieval of a single paper based on closest title match to given query. Examples: <ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search/match?query=Construction of the Literature Graph in Semantic Scholar</code></li>   <ul>     <li>Returns a single paper that is the closest title match.</li>     <li>Each paper has its paperId, title, and matchScore as well as any other requested fields.</li>   </ul>   <li><code>https://api.semanticscholar.org/graph/v1/paper/search/match?query=totalGarbageNonsense</code></li>   <ul>     <li>Returns with a 404 error and a \"Title match not found\" message.</li>   </ul> </ul>   <br>     Limitations:     <ul>         <li>Will only return the single highest match result.</li>     </ul> </ul>
     * Paper title search
     */
    async getGraphPaperTitleSearch(requestParameters: GetGraphPaperTitleSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaperMatch> {
        const response = await this.getGraphPaperTitleSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * * Fields is a single-value string parameter, not a multi-value one. * It is a query parameter, not to be submitted in the POST request\'s body.  In python:      r = requests.post(         \'https://api.semanticscholar.org/graph/v1/paper/batch\',         params={\'fields\': \'referenceCount,citationCount,title\'},         json={\"ids\": [\"649def34f8be52c8b66281af98ae884c09aef38b\", \"ARXIV:2106.15928\"]}     )     print(json.dumps(r.json(), indent=2))      [       {         \"paperId\": \"649def34f8be52c8b66281af98ae884c09aef38b\",         \"title\": \"Construction of the Literature Graph in Semantic Scholar\",         \"referenceCount\": 27,         \"citationCount\": 299       },       {         \"paperId\": \"f712fab0d58ae6492e3cdfc1933dae103ec12d5d\",         \"title\": \"Reinfection and low cross-immunity as drivers of epidemic resurgence under high seroprevalence: a model-based approach with application to Amazonas, Brazil\",         \"referenceCount\": 13,         \"citationCount\": 0       }     ]  Other Examples: <ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/batch</code></li>     <ul>         <li><code>{\"ids\":[\"649def34f8be52c8b66281af98ae884c09aef38b\", \"ARXIV:2106.15928\"]}</code></li>         <li>Returns details for 2 papers.</li>         <li>Each paper has its paperId and title.  </li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/batch?fields=title,isOpenAccess,openAccessPdf,authors</code></li>     <ul>         <li><code>{\"ids\":[\"649def34f8be52c8b66281af98ae884c09aef38b\", \"ARXIV:2106.15928\"]}</code></li>         <li>Returns all requested info plus paper IDs for 2 papers.</li>     </ul> </ul> <br> Limitations: <ul>     <li>Can only process 500 paper ids at a time.</li>     <li>Can only return up to 10 MB of data at a time.</li>     <li>Can only return up to 9999 citations at a time.</li>     <li>For a list of supported IDs reference the \"Details about a paper\" endpoint.</li> </ul>
     * Get details for multiple papers at once
     */
    async postGraphGetPapersRaw(requestParameters: PostGraphGetPapersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullPaper>> {
        if (requestParameters['payload'] == null) {
            throw new runtime.RequiredError(
                'payload',
                'Required parameter "payload" was null or undefined when calling postGraphGetPapers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fields'] != null) {
            queryParameters['fields'] = requestParameters['fields'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/paper/batch`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PaperBatchToJSON(requestParameters['payload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullPaperFromJSON(jsonValue));
    }

    /**
     * * Fields is a single-value string parameter, not a multi-value one. * It is a query parameter, not to be submitted in the POST request\'s body.  In python:      r = requests.post(         \'https://api.semanticscholar.org/graph/v1/paper/batch\',         params={\'fields\': \'referenceCount,citationCount,title\'},         json={\"ids\": [\"649def34f8be52c8b66281af98ae884c09aef38b\", \"ARXIV:2106.15928\"]}     )     print(json.dumps(r.json(), indent=2))      [       {         \"paperId\": \"649def34f8be52c8b66281af98ae884c09aef38b\",         \"title\": \"Construction of the Literature Graph in Semantic Scholar\",         \"referenceCount\": 27,         \"citationCount\": 299       },       {         \"paperId\": \"f712fab0d58ae6492e3cdfc1933dae103ec12d5d\",         \"title\": \"Reinfection and low cross-immunity as drivers of epidemic resurgence under high seroprevalence: a model-based approach with application to Amazonas, Brazil\",         \"referenceCount\": 13,         \"citationCount\": 0       }     ]  Other Examples: <ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/batch</code></li>     <ul>         <li><code>{\"ids\":[\"649def34f8be52c8b66281af98ae884c09aef38b\", \"ARXIV:2106.15928\"]}</code></li>         <li>Returns details for 2 papers.</li>         <li>Each paper has its paperId and title.  </li>     </ul>     <li><code>https://api.semanticscholar.org/graph/v1/paper/batch?fields=title,isOpenAccess,openAccessPdf,authors</code></li>     <ul>         <li><code>{\"ids\":[\"649def34f8be52c8b66281af98ae884c09aef38b\", \"ARXIV:2106.15928\"]}</code></li>         <li>Returns all requested info plus paper IDs for 2 papers.</li>     </ul> </ul> <br> Limitations: <ul>     <li>Can only process 500 paper ids at a time.</li>     <li>Can only return up to 10 MB of data at a time.</li>     <li>Can only return up to 9999 citations at a time.</li>     <li>For a list of supported IDs reference the \"Details about a paper\" endpoint.</li> </ul>
     * Get details for multiple papers at once
     */
    async postGraphGetPapers(requestParameters: PostGraphGetPapersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullPaper> {
        const response = await this.postGraphGetPapersRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

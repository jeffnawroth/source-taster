/* tslint:disable */
/* eslint-disable */
/**
 * OpenAlex
 * ![](https://raw.githubusercontent.com/ourresearch/openalex-docs/main/.gitbook/assets/OpenAlex-logo-5.png)  **OpenAlex** is a fully open catalog of the global research system.  It\'s named after the [ancient Library of Alexandria](https://en.wikipedia.org/wiki/Library_of_Alexandria) and made by the nonprofit [OurResearch](https://ourresearch.org/).  ## OpenAPI Specification  [Mearman/openalex-api-spec](https://github.com/Mearman/openalex-api-spec)  This OpenAPI specification is reverse-engineered and derived from spec generated by [openapi-devtools](https://github.com/AndrewWalsh/openapi-devtools).  The specification document itself is OpenAPI version 3.1 and is generated from TypeScript source code.  [![Open in](https://img.shields.io/badge/Open%20in-Swagger%20UI-85EA2D?style=for-the-badge&logo=Swagger&link=https://mearman.github.io/openalex-swagger-ui-react/)](https://mearman.github.io/openalex-swagger-ui-react/)  **[Releases](https://github.com/Mearman/openalex-api-spec/releases)**  ## Clients  [![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&logo=TypeScript&logoColor=white&link=https://github.com/Mearman/openalex-typescript)](https://github.com/Mearman/openalex-typescript)  [![TypeScript Fetch](https://img.shields.io/badge/TypeScript%20Fetch-3178C6?style=for-the-badge&logo=TypeScript&logoColor=white&link=https://github.com/Mearman/openalex-typescript-fetch)](https://github.com/Mearman/openalex-typescript-fetch)  [![TypeScript Node](https://img.shields.io/badge/TypeScript%20Node-339933?style=for-the-badge&logo=Node.js&logoColor=white&link=https://github.com/Mearman/openalex-typescript-node)](https://github.com/Mearman/openalex-typescript-node)  [![Python](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=Python&logoColor=white&link=https://github.com/Mearman/openalex-python)](https://github.com/Mearman/openalex-python) [![Open in](https://img.shields.io/badge/Open%20in-CodeSpaces-181717?style=for-the-badge&logo=GitHub&link=https://codespaces.new/Mearman/openalex-python)](https://codespaces.new/Mearman/openalex-python) [![Open in](https://img.shields.io/badge/Open%20in-Colab-F9AB00?style=for-the-badge&logo=Google%20Colab&link=https://colab.research.google.com/github/Mearman/openalex-python/blob/main/README.ipynb)](https://colab.research.google.com/github/Mearman/openalex-python/blob/main/README.ipynb)  ---
 *
 * The version of the OpenAPI document: 0.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Author,
  Authors,
  AutoCompleteResultSchema,
  BaseSelectionAttributes,
  Concept,
  Concepts,
  Domain,
  ErrorMessage,
  Field,
  Funder,
  FundersArray,
  Institution,
  Institutions,
  Ngrams,
  Person,
  Publisher,
  Publishers,
  RootResponseSchema,
  Source,
  Sources,
  Subfield,
  Topic,
  Topics,
  Work,
  WorkAttributes,
  WorksResponse,
} from '../models/index';
import {
    AuthorFromJSON,
    AuthorToJSON,
    AuthorsFromJSON,
    AuthorsToJSON,
    AutoCompleteResultSchemaFromJSON,
    AutoCompleteResultSchemaToJSON,
    BaseSelectionAttributesFromJSON,
    BaseSelectionAttributesToJSON,
    ConceptFromJSON,
    ConceptToJSON,
    ConceptsFromJSON,
    ConceptsToJSON,
    DomainFromJSON,
    DomainToJSON,
    ErrorMessageFromJSON,
    ErrorMessageToJSON,
    FieldFromJSON,
    FieldToJSON,
    FunderFromJSON,
    FunderToJSON,
    FundersArrayFromJSON,
    FundersArrayToJSON,
    InstitutionFromJSON,
    InstitutionToJSON,
    InstitutionsFromJSON,
    InstitutionsToJSON,
    NgramsFromJSON,
    NgramsToJSON,
    PersonFromJSON,
    PersonToJSON,
    PublisherFromJSON,
    PublisherToJSON,
    PublishersFromJSON,
    PublishersToJSON,
    RootResponseSchemaFromJSON,
    RootResponseSchemaToJSON,
    SourceFromJSON,
    SourceToJSON,
    SourcesFromJSON,
    SourcesToJSON,
    SubfieldFromJSON,
    SubfieldToJSON,
    TopicFromJSON,
    TopicToJSON,
    TopicsFromJSON,
    TopicsToJSON,
    WorkFromJSON,
    WorkToJSON,
    WorkAttributesFromJSON,
    WorkAttributesToJSON,
    WorksResponseFromJSON,
    WorksResponseToJSON,
} from '../models/index';

export interface GetAuthorRequest {
    id: string;
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetAuthorsRequest {
    apiKey?: string;
    cursor?: string;
    filter?: string;
    groupBy?: string;
    page?: number;
    perPage?: number;
    sample?: number;
    search?: string;
    seed?: any;
    select?: string;
    sort?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetAutocompleteRequest {
    q?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetAutocompleteAuthorsRequest {
    q?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetAutocompleteConceptsRequest {
    q?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetAutocompleteFundersRequest {
    q?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetAutocompleteInstitutionsRequest {
    q?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetAutocompletePublishersRequest {
    q?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetAutocompleteSourcesRequest {
    q?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetAutocompleteWorksRequest {
    filter?: string;
    search?: string;
    q?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetConceptByIdRequest {
    id: string;
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetConceptsRequest {
    apiKey?: string;
    cursor?: string;
    filter?: string;
    groupBy?: string;
    page?: number;
    perPage?: number;
    sample?: number;
    search?: string;
    seed?: any;
    select?: string;
    sort?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetDomainByIdRequest {
    id: string;
    perPage?: number;
    userAgent?: string;
    mailto?: string;
}

export interface GetFieldByIdRequest {
    id: string;
    perPage?: number;
    userAgent?: string;
    mailto?: string;
}

export interface GetFunderRequest {
    id: string;
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetFundersRequest {
    apiKey?: string;
    cursor?: string;
    filter?: string;
    groupBy?: string;
    page?: number;
    perPage?: number;
    sample?: number;
    search?: string;
    seed?: any;
    select?: string;
    sort?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetInstitutionRequest {
    id: string;
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetInstitutionsRequest {
    apiKey?: string;
    cursor?: string;
    filter?: string;
    groupBy?: string;
    page?: number;
    perPage?: number;
    sample?: number;
    search?: string;
    seed?: any;
    select?: string;
    sort?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetPersonRequest {
    id: string;
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetPublisherRequest {
    id: string;
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetPublishersRequest {
    apiKey?: string;
    cursor?: string;
    filter?: string;
    groupBy?: string;
    page?: number;
    perPage?: number;
    sample?: number;
    search?: string;
    seed?: any;
    select?: string;
    sort?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetRandomAuthorRequest {
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetRandomConceptRequest {
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetRandomFunderRequest {
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetRandomInstitutionRequest {
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetRandomPublisherRequest {
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetRandomSourceRequest {
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetRandomWorkRequest {
    select?: Array<WorkAttributes & BaseSelectionAttributes>;
    userAgent?: string;
    mailto?: string;
}

export interface GetRootRequest {
    userAgent?: string;
    mailto?: string;
}

export interface GetSourceRequest {
    id: string;
    select?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetSourcesRequest {
    groupBy?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetSubfieldByIdRequest {
    id: string;
    perPage?: number;
    userAgent?: string;
    mailto?: string;
}

export interface GetTopicByIdRequest {
    id: string;
    perPage?: number;
    userAgent?: string;
    mailto?: string;
}

export interface GetTopicsRequest {
    sort?: string;
    perPage?: number;
    page?: string;
    sample?: string;
    select?: string;
    filter?: string;
    search?: string;
    groupBy?: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetWorkRequest {
    id: string;
    select?: Array<WorkAttributes & BaseSelectionAttributes>;
    userAgent?: string;
    mailto?: string;
}

export interface GetWorkNgramsRequest {
    id: string;
    userAgent?: string;
    mailto?: string;
}

export interface GetWorksRequest {
    apiKey?: string;
    cursor?: string;
    groupBy?: string;
    page?: number;
    perPage?: number;
    sample?: number;
    search?: string;
    seed?: any;
    select?: string;
    sort?: string;
    filter?: string;
    userAgent?: string;
    mailto?: string;
}

/**
 * OpenAlexApi - interface
 * 
 * @export
 * @interface OpenAlexApiInterface
 */
export interface OpenAlexApiInterface {
    /**
     * Get a single author by id
     * @summary Get Author
     * @param {string} id 
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAuthorRaw(requestParameters: GetAuthorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Author>>;

    /**
     * Get a single author by id
     * Get Author
     */
    getAuthor(requestParameters: GetAuthorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Author>;

    /**
     * Get lists of authors
     * @summary List Authors
     * @param {string} [apiKey] 
     * @param {string} [cursor] 
     * @param {string} [filter] 
     * @param {string} [groupBy] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [sample] 
     * @param {string} [search] 
     * @param {any} [seed] 
     * @param {string} [select] 
     * @param {string} [sort] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAuthorsRaw(requestParameters: GetAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Authors>>;

    /**
     * Get lists of authors
     * List Authors
     */
    getAuthors(requestParameters: GetAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Authors>;

    /**
     * 
     * @summary /autocomplete
     * @param {string} [q] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAutocompleteRaw(requestParameters: GetAutocompleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>>;

    /**
     * 
     * /autocomplete
     */
    getAutocomplete(requestParameters: GetAutocompleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema>;

    /**
     * 
     * @summary /autocomplete/authors
     * @param {string} [q] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAutocompleteAuthorsRaw(requestParameters: GetAutocompleteAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>>;

    /**
     * 
     * /autocomplete/authors
     */
    getAutocompleteAuthors(requestParameters: GetAutocompleteAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema>;

    /**
     * 
     * @summary /autocomplete/concepts
     * @param {string} [q] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAutocompleteConceptsRaw(requestParameters: GetAutocompleteConceptsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>>;

    /**
     * 
     * /autocomplete/concepts
     */
    getAutocompleteConcepts(requestParameters: GetAutocompleteConceptsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema>;

    /**
     * 
     * @summary /autocomplete/funders
     * @param {string} [q] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAutocompleteFundersRaw(requestParameters: GetAutocompleteFundersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>>;

    /**
     * 
     * /autocomplete/funders
     */
    getAutocompleteFunders(requestParameters: GetAutocompleteFundersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema>;

    /**
     * 
     * @summary /autocomplete/institutions
     * @param {string} [q] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAutocompleteInstitutionsRaw(requestParameters: GetAutocompleteInstitutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>>;

    /**
     * 
     * /autocomplete/institutions
     */
    getAutocompleteInstitutions(requestParameters: GetAutocompleteInstitutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema>;

    /**
     * 
     * @summary /autocomplete/publishers
     * @param {string} [q] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAutocompletePublishersRaw(requestParameters: GetAutocompletePublishersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>>;

    /**
     * 
     * /autocomplete/publishers
     */
    getAutocompletePublishers(requestParameters: GetAutocompletePublishersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema>;

    /**
     * 
     * @summary /autocomplete/sources
     * @param {string} [q] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAutocompleteSourcesRaw(requestParameters: GetAutocompleteSourcesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>>;

    /**
     * 
     * /autocomplete/sources
     */
    getAutocompleteSources(requestParameters: GetAutocompleteSourcesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema>;

    /**
     * 
     * @summary /autocomplete/works
     * @param {string} [filter] 
     * @param {string} [search] 
     * @param {string} [q] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getAutocompleteWorksRaw(requestParameters: GetAutocompleteWorksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>>;

    /**
     * 
     * /autocomplete/works
     */
    getAutocompleteWorks(requestParameters: GetAutocompleteWorksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema>;

    /**
     * Get a single concept
     * @summary /concepts/{id}
     * @param {string} id 
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getConceptByIdRaw(requestParameters: GetConceptByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Concept>>;

    /**
     * Get a single concept
     * /concepts/{id}
     */
    getConceptById(requestParameters: GetConceptByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Concept>;

    /**
     * 
     * @summary /concepts
     * @param {string} [apiKey] 
     * @param {string} [cursor] 
     * @param {string} [filter] 
     * @param {string} [groupBy] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [sample] 
     * @param {string} [search] 
     * @param {any} [seed] 
     * @param {string} [select] 
     * @param {string} [sort] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getConceptsRaw(requestParameters: GetConceptsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Concepts>>;

    /**
     * 
     * /concepts
     */
    getConcepts(requestParameters: GetConceptsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Concepts>;

    /**
     * 
     * @summary /domains/{id}
     * @param {string} id 
     * @param {number} [perPage] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getDomainByIdRaw(requestParameters: GetDomainByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Domain>>;

    /**
     * 
     * /domains/{id}
     */
    getDomainById(requestParameters: GetDomainByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Domain>;

    /**
     * 
     * @summary /fields/{id}
     * @param {string} id 
     * @param {number} [perPage] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getFieldByIdRaw(requestParameters: GetFieldByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Field>>;

    /**
     * 
     * /fields/{id}
     */
    getFieldById(requestParameters: GetFieldByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Field>;

    /**
     * 
     * @summary /funders/{id}
     * @param {string} id 
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getFunderRaw(requestParameters: GetFunderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Funder>>;

    /**
     * 
     * /funders/{id}
     */
    getFunder(requestParameters: GetFunderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Funder>;

    /**
     * 
     * @summary /funders
     * @param {string} [apiKey] 
     * @param {string} [cursor] 
     * @param {string} [filter] 
     * @param {string} [groupBy] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [sample] 
     * @param {string} [search] 
     * @param {any} [seed] 
     * @param {string} [select] 
     * @param {string} [sort] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getFundersRaw(requestParameters: GetFundersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FundersArray>>;

    /**
     * 
     * /funders
     */
    getFunders(requestParameters: GetFundersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FundersArray>;

    /**
     * 
     * @summary /institutions/{id}
     * @param {string} id 
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getInstitutionRaw(requestParameters: GetInstitutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Institution>>;

    /**
     * 
     * /institutions/{id}
     */
    getInstitution(requestParameters: GetInstitutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Institution>;

    /**
     * 
     * @summary /institutions
     * @param {string} [apiKey] 
     * @param {string} [cursor] 
     * @param {string} [filter] 
     * @param {string} [groupBy] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [sample] 
     * @param {string} [search] 
     * @param {any} [seed] 
     * @param {string} [select] 
     * @param {string} [sort] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getInstitutionsRaw(requestParameters: GetInstitutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Institutions>>;

    /**
     * 
     * /institutions
     */
    getInstitutions(requestParameters: GetInstitutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Institutions>;

    /**
     * 
     * @summary /people/{id}
     * @param {string} id 
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getPersonRaw(requestParameters: GetPersonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Person>>;

    /**
     * 
     * /people/{id}
     */
    getPerson(requestParameters: GetPersonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Person>;

    /**
     * 
     * @summary /publishers/{id}
     * @param {string} id 
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getPublisherRaw(requestParameters: GetPublisherRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Publisher>>;

    /**
     * 
     * /publishers/{id}
     */
    getPublisher(requestParameters: GetPublisherRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Publisher>;

    /**
     * 
     * @summary /publishers
     * @param {string} [apiKey] 
     * @param {string} [cursor] 
     * @param {string} [filter] 
     * @param {string} [groupBy] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [sample] 
     * @param {string} [search] 
     * @param {any} [seed] 
     * @param {string} [select] 
     * @param {string} [sort] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getPublishersRaw(requestParameters: GetPublishersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Publishers>>;

    /**
     * 
     * /publishers
     */
    getPublishers(requestParameters: GetPublishersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Publishers>;

    /**
     * Get a random author
     * @summary Get Random Author
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getRandomAuthorRaw(requestParameters: GetRandomAuthorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Author>>;

    /**
     * Get a random author
     * Get Random Author
     */
    getRandomAuthor(requestParameters: GetRandomAuthorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Author>;

    /**
     * Get a random concept
     * @summary /concepts/random
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getRandomConceptRaw(requestParameters: GetRandomConceptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Concept>>;

    /**
     * Get a random concept
     * /concepts/random
     */
    getRandomConcept(requestParameters: GetRandomConceptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Concept>;

    /**
     * Get a random funder
     * @summary /funders/random
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getRandomFunderRaw(requestParameters: GetRandomFunderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Funder>>;

    /**
     * Get a random funder
     * /funders/random
     */
    getRandomFunder(requestParameters: GetRandomFunderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Funder>;

    /**
     * Get a random institution
     * @summary /institutions/random
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getRandomInstitutionRaw(requestParameters: GetRandomInstitutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Institution>>;

    /**
     * Get a random institution
     * /institutions/random
     */
    getRandomInstitution(requestParameters: GetRandomInstitutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Institution>;

    /**
     * Get a random publisher
     * @summary /publishers/random
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getRandomPublisherRaw(requestParameters: GetRandomPublisherRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Publisher>>;

    /**
     * Get a random publisher
     * /publishers/random
     */
    getRandomPublisher(requestParameters: GetRandomPublisherRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Publisher>;

    /**
     * Get a random source
     * @summary /sources/random
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getRandomSourceRaw(requestParameters: GetRandomSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Source>>;

    /**
     * Get a random source
     * /sources/random
     */
    getRandomSource(requestParameters: GetRandomSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Source>;

    /**
     * Get a random work
     * @summary /works/random
     * @param {Array<WorkAttributes & BaseSelectionAttributes>} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getRandomWorkRaw(requestParameters: GetRandomWorkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Work>>;

    /**
     * Get a random work
     * /works/random
     */
    getRandomWork(requestParameters: GetRandomWorkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Work>;

    /**
     * Root endpoint
     * @summary Root
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getRootRaw(requestParameters: GetRootRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RootResponseSchema>>;

    /**
     * Root endpoint
     * Root
     */
    getRoot(requestParameters: GetRootRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RootResponseSchema>;

    /**
     * 
     * @summary /sources/{id}
     * @param {string} id 
     * @param {string} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getSourceRaw(requestParameters: GetSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Source>>;

    /**
     * 
     * /sources/{id}
     */
    getSource(requestParameters: GetSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Source>;

    /**
     * 
     * @summary /sources
     * @param {string} [groupBy] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getSourcesRaw(requestParameters: GetSourcesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Sources>>;

    /**
     * 
     * /sources
     */
    getSources(requestParameters: GetSourcesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Sources>;

    /**
     * 
     * @summary /subfields/{id}
     * @param {string} id 
     * @param {number} [perPage] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getSubfieldByIdRaw(requestParameters: GetSubfieldByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subfield>>;

    /**
     * 
     * /subfields/{id}
     */
    getSubfieldById(requestParameters: GetSubfieldByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subfield>;

    /**
     * 
     * @summary /topics/{id}
     * @param {string} id 
     * @param {number} [perPage] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getTopicByIdRaw(requestParameters: GetTopicByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Topic>>;

    /**
     * 
     * /topics/{id}
     */
    getTopicById(requestParameters: GetTopicByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Topic>;

    /**
     * 
     * @summary /topics
     * @param {string} [sort] 
     * @param {number} [perPage] 
     * @param {string} [page] 
     * @param {string} [sample] 
     * @param {string} [select] 
     * @param {string} [filter] 
     * @param {string} [search] 
     * @param {string} [groupBy] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getTopicsRaw(requestParameters: GetTopicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Topics>>;

    /**
     * 
     * /topics
     */
    getTopics(requestParameters: GetTopicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Topics>;

    /**
     * Get a single work by its id
     * @summary /works/{id}
     * @param {string} id The id of the work to retrieve
     * @param {Array<WorkAttributes & BaseSelectionAttributes>} [select] 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getWorkRaw(requestParameters: GetWorkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Work>>;

    /**
     * Get a single work by its id
     * /works/{id}
     */
    getWork(requestParameters: GetWorkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Work>;

    /**
     * 
     * @summary /works/{id}/ngrams
     * @param {string} id 
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getWorkNgramsRaw(requestParameters: GetWorkNgramsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Ngrams>>;

    /**
     * 
     * /works/{id}/ngrams
     */
    getWorkNgrams(requestParameters: GetWorkNgramsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Ngrams>;

    /**
     * 
     * @summary /works
     * @param {string} [apiKey] 
     * @param {string} [cursor] 
     * @param {string} [groupBy] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [sample] 
     * @param {string} [search] 
     * @param {any} [seed] 
     * @param {string} [select] 
     * @param {string} [sort] 
     * @param {string} [filter] Filter works by a specific field. See the [filter works](https://docs.openalex.org/api-entities/works/filter-works) documentation for more information. Valid filters are:   - &#x60;abstract.search&#x60; - &#x60;apc_list.currency&#x60; - &#x60;apc_list.provenance&#x60; - &#x60;apc_list.value&#x60; - &#x60;apc_list.value_usd&#x60; - &#x60;apc_paid.currency&#x60; - &#x60;apc_paid.provenance&#x60; - &#x60;apc_paid.value&#x60; - &#x60;apc_paid.value_usd&#x60; - &#x60;author.id&#x60; - &#x60;author.orcid&#x60; - &#x60;authors_count&#x60; - &#x60;authorships.author.id&#x60; - &#x60;authorships.author.orcid&#x60; - &#x60;authorships.countries&#x60; - &#x60;authorships.institutions.continent&#x60; - &#x60;authorships.institutions.country_code&#x60; - &#x60;authorships.institutions.id&#x60; - &#x60;authorships.institutions.is_global_south&#x60; - &#x60;authorships.institutions.lineage&#x60; - &#x60;authorships.institutions.ror&#x60; - &#x60;authorships.institutions.type&#x60; - &#x60;authorships.is_corresponding&#x60; - &#x60;best_oa_location.is_accepted&#x60; - &#x60;best_oa_location.is_oa&#x60; - &#x60;best_oa_location.is_published&#x60; - &#x60;best_oa_location.landing_page_url&#x60; - &#x60;best_oa_location.license&#x60; - &#x60;best_oa_location.source.host_organization&#x60; - &#x60;best_oa_location.source.host_organization_lineage&#x60; - &#x60;best_oa_location.source.id&#x60; - &#x60;best_oa_location.source.is_in_doaj&#x60; - &#x60;best_oa_location.source.is_oa&#x60; - &#x60;best_oa_location.source.issn&#x60; - &#x60;best_oa_location.source.type&#x60; - &#x60;best_oa_location.version&#x60; - &#x60;best_open_version&#x60; - &#x60;cited_by&#x60; - &#x60;cited_by_count&#x60; - &#x60;cited_by_percentile_year.max&#x60; - &#x60;cited_by_percentile_year.min&#x60; - &#x60;cites&#x60; - &#x60;concept.id&#x60; - &#x60;concepts.id&#x60; - &#x60;concepts.wikidata&#x60; - &#x60;concepts_count&#x60; - &#x60;corresponding_author_ids&#x60; - &#x60;corresponding_institution_ids&#x60; - &#x60;countries_distinct_count&#x60; - &#x60;default.search&#x60; - &#x60;display_name&#x60; - &#x60;display_name.search&#x60; - &#x60;doi&#x60; - &#x60;doi_starts_with&#x60; - &#x60;from_created_date&#x60; - &#x60;from_publication_date&#x60; - &#x60;fulltext.search&#x60; - &#x60;fulltext_origin&#x60; - &#x60;grants.award_id&#x60; - &#x60;grants.funder&#x60; - &#x60;has_abstract&#x60; - &#x60;has_doi&#x60; - &#x60;has_fulltext&#x60; - &#x60;has_ngrams&#x60; - &#x60;has_oa_accepted_or_published_version&#x60; - &#x60;has_oa_submitted_version&#x60; - &#x60;has_old_authors&#x60; - &#x60;has_orcid&#x60; - &#x60;has_pdf_url&#x60; - &#x60;has_pmcid&#x60; - &#x60;has_pmid&#x60; - &#x60;has_raw_affiliation_string&#x60; - &#x60;has_references&#x60; - &#x60;host_venue.id&#x60; - &#x60;ids.mag&#x60; - &#x60;ids.openalex&#x60; - &#x60;ids.pmcid&#x60; - &#x60;ids.pmid&#x60; - &#x60;institution.id&#x60; - &#x60;institutions.continent&#x60; - &#x60;institutions.country_code&#x60; - &#x60;institutions.id&#x60; - &#x60;institutions.is_global_south&#x60; - &#x60;institutions.ror&#x60; - &#x60;institutions.type&#x60; - &#x60;institutions_distinct_count&#x60; - &#x60;is_corresponding&#x60; - &#x60;is_oa&#x60; - &#x60;is_paratext&#x60; - &#x60;is_retracted&#x60; - &#x60;journal&#x60; - &#x60;keyword.search&#x60; - &#x60;keywords.keyword&#x60; - &#x60;language&#x60; - &#x60;locations.is_accepted&#x60; - &#x60;locations.is_oa&#x60; - &#x60;locations.is_published&#x60; - &#x60;locations.landing_page_url&#x60; - &#x60;locations.license&#x60; - &#x60;locations.source.has_issn&#x60; - &#x60;locations.source.host_institution_lineage&#x60; - &#x60;locations.source.host_organization&#x60; - &#x60;locations.source.host_organization_lineage&#x60; - &#x60;locations.source.id&#x60; - &#x60;locations.source.is_in_doaj&#x60; - &#x60;locations.source.is_oa&#x60; - &#x60;locations.source.issn&#x60; - &#x60;locations.source.publisher_lineage&#x60; - &#x60;locations.source.type&#x60; - &#x60;locations.version&#x60; - &#x60;locations_count&#x60; - &#x60;mag&#x60; - &#x60;oa_status&#x60; - &#x60;open_access.any_repository_has_fulltext&#x60; - &#x60;open_access.is_oa&#x60; - &#x60;open_access.oa_status&#x60; - &#x60;openalex&#x60; - &#x60;openalex_id&#x60; - &#x60;pmcid&#x60; - &#x60;pmid&#x60; - &#x60;primary_location.is_accepted&#x60; - &#x60;primary_location.is_oa&#x60; - &#x60;primary_location.is_published&#x60; - &#x60;primary_location.landing_page_url&#x60; - &#x60;primary_location.license&#x60; - &#x60;primary_location.source.has_issn&#x60; - &#x60;primary_location.source.host_institution_lineage&#x60; - &#x60;primary_location.source.host_organization&#x60; - &#x60;primary_location.source.host_organization_lineage&#x60; - &#x60;primary_location.source.id&#x60; - &#x60;primary_location.source.is_in_doaj&#x60; - &#x60;primary_location.source.is_oa&#x60; - &#x60;primary_location.source.issn&#x60; - &#x60;primary_location.source.publisher_lineage&#x60; - &#x60;primary_location.source.type&#x60; - &#x60;primary_location.version&#x60; - &#x60;publication_date&#x60; - &#x60;publication_year&#x60; - &#x60;raw_affiliation_string.search&#x60; - &#x60;referenced_works&#x60; - &#x60;referenced_works_count&#x60; - &#x60;related_to&#x60; - &#x60;repository&#x60; - &#x60;sustainable_development_goals.id&#x60; - &#x60;sustainable_development_goals.score&#x60; - &#x60;title.search&#x60; - &#x60;title_and_abstract.search&#x60; - &#x60;to_publication_date&#x60; - &#x60;to_updated_date&#x60; - &#x60;type&#x60; - &#x60;type_crossref&#x60; - &#x60;version&#x60;
     * @param {string} [userAgent] [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool)
     * @param {string} [mailto] The API is the primary way to get OpenAlex data. It\&#39;s free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day. For best performance, add your email to all API requests The email can be either in the query string, like &#x60;mailto:example@domain.com&#x60;, or in the User-Agent request header, like &#x60;User-Agent: my-app (mailto:example@domain.com)&#x60;. Read more about the polite pool at [docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication](https://docs.openalex.org/how-to-use-the-api/rate-limits-and-authentication#the-polite-pool).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAlexApiInterface
     */
    getWorksRaw(requestParameters: GetWorksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorksResponse>>;

    /**
     * 
     * /works
     */
    getWorks(requestParameters: GetWorksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorksResponse>;

}

/**
 * 
 */
export class OpenAlexApi extends runtime.BaseAPI implements OpenAlexApiInterface {

    /**
     * Get a single author by id
     * Get Author
     */
    async getAuthorRaw(requestParameters: GetAuthorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Author>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getAuthor().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/authors/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorFromJSON(jsonValue));
    }

    /**
     * Get a single author by id
     * Get Author
     */
    async getAuthor(requestParameters: GetAuthorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Author> {
        const response = await this.getAuthorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get lists of authors
     * List Authors
     */
    async getAuthorsRaw(requestParameters: GetAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Authors>> {
        const queryParameters: any = {};

        if (requestParameters['apiKey'] != null) {
            queryParameters['api_key'] = requestParameters['apiKey'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['sample'] != null) {
            queryParameters['sample'] = requestParameters['sample'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['seed'] != null) {
            queryParameters['seed'] = requestParameters['seed'];
        }

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/authors`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorsFromJSON(jsonValue));
    }

    /**
     * Get lists of authors
     * List Authors
     */
    async getAuthors(requestParameters: GetAuthorsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Authors> {
        const response = await this.getAuthorsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /autocomplete
     */
    async getAutocompleteRaw(requestParameters: GetAutocompleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>> {
        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/autocomplete`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutoCompleteResultSchemaFromJSON(jsonValue));
    }

    /**
     * 
     * /autocomplete
     */
    async getAutocomplete(requestParameters: GetAutocompleteRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema> {
        const response = await this.getAutocompleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /autocomplete/authors
     */
    async getAutocompleteAuthorsRaw(requestParameters: GetAutocompleteAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>> {
        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/autocomplete/authors`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutoCompleteResultSchemaFromJSON(jsonValue));
    }

    /**
     * 
     * /autocomplete/authors
     */
    async getAutocompleteAuthors(requestParameters: GetAutocompleteAuthorsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema> {
        const response = await this.getAutocompleteAuthorsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /autocomplete/concepts
     */
    async getAutocompleteConceptsRaw(requestParameters: GetAutocompleteConceptsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>> {
        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/autocomplete/concepts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutoCompleteResultSchemaFromJSON(jsonValue));
    }

    /**
     * 
     * /autocomplete/concepts
     */
    async getAutocompleteConcepts(requestParameters: GetAutocompleteConceptsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema> {
        const response = await this.getAutocompleteConceptsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /autocomplete/funders
     */
    async getAutocompleteFundersRaw(requestParameters: GetAutocompleteFundersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>> {
        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/autocomplete/funders`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutoCompleteResultSchemaFromJSON(jsonValue));
    }

    /**
     * 
     * /autocomplete/funders
     */
    async getAutocompleteFunders(requestParameters: GetAutocompleteFundersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema> {
        const response = await this.getAutocompleteFundersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /autocomplete/institutions
     */
    async getAutocompleteInstitutionsRaw(requestParameters: GetAutocompleteInstitutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>> {
        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/autocomplete/institutions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutoCompleteResultSchemaFromJSON(jsonValue));
    }

    /**
     * 
     * /autocomplete/institutions
     */
    async getAutocompleteInstitutions(requestParameters: GetAutocompleteInstitutionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema> {
        const response = await this.getAutocompleteInstitutionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /autocomplete/publishers
     */
    async getAutocompletePublishersRaw(requestParameters: GetAutocompletePublishersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>> {
        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/autocomplete/publishers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutoCompleteResultSchemaFromJSON(jsonValue));
    }

    /**
     * 
     * /autocomplete/publishers
     */
    async getAutocompletePublishers(requestParameters: GetAutocompletePublishersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema> {
        const response = await this.getAutocompletePublishersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /autocomplete/sources
     */
    async getAutocompleteSourcesRaw(requestParameters: GetAutocompleteSourcesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>> {
        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/autocomplete/sources`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutoCompleteResultSchemaFromJSON(jsonValue));
    }

    /**
     * 
     * /autocomplete/sources
     */
    async getAutocompleteSources(requestParameters: GetAutocompleteSourcesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema> {
        const response = await this.getAutocompleteSourcesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /autocomplete/works
     */
    async getAutocompleteWorksRaw(requestParameters: GetAutocompleteWorksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoCompleteResultSchema>> {
        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/autocomplete/works`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutoCompleteResultSchemaFromJSON(jsonValue));
    }

    /**
     * 
     * /autocomplete/works
     */
    async getAutocompleteWorks(requestParameters: GetAutocompleteWorksRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoCompleteResultSchema> {
        const response = await this.getAutocompleteWorksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a single concept
     * /concepts/{id}
     */
    async getConceptByIdRaw(requestParameters: GetConceptByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Concept>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getConceptById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/concepts/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConceptFromJSON(jsonValue));
    }

    /**
     * Get a single concept
     * /concepts/{id}
     */
    async getConceptById(requestParameters: GetConceptByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Concept> {
        const response = await this.getConceptByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /concepts
     */
    async getConceptsRaw(requestParameters: GetConceptsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Concepts>> {
        const queryParameters: any = {};

        if (requestParameters['apiKey'] != null) {
            queryParameters['api_key'] = requestParameters['apiKey'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['sample'] != null) {
            queryParameters['sample'] = requestParameters['sample'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['seed'] != null) {
            queryParameters['seed'] = requestParameters['seed'];
        }

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/concepts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConceptsFromJSON(jsonValue));
    }

    /**
     * 
     * /concepts
     */
    async getConcepts(requestParameters: GetConceptsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Concepts> {
        const response = await this.getConceptsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /domains/{id}
     */
    async getDomainByIdRaw(requestParameters: GetDomainByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Domain>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getDomainById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/domains/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DomainFromJSON(jsonValue));
    }

    /**
     * 
     * /domains/{id}
     */
    async getDomainById(requestParameters: GetDomainByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Domain> {
        const response = await this.getDomainByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /fields/{id}
     */
    async getFieldByIdRaw(requestParameters: GetFieldByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Field>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getFieldById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/field/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FieldFromJSON(jsonValue));
    }

    /**
     * 
     * /fields/{id}
     */
    async getFieldById(requestParameters: GetFieldByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Field> {
        const response = await this.getFieldByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /funders/{id}
     */
    async getFunderRaw(requestParameters: GetFunderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Funder>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getFunder().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/funders/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FunderFromJSON(jsonValue));
    }

    /**
     * 
     * /funders/{id}
     */
    async getFunder(requestParameters: GetFunderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Funder> {
        const response = await this.getFunderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /funders
     */
    async getFundersRaw(requestParameters: GetFundersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FundersArray>> {
        const queryParameters: any = {};

        if (requestParameters['apiKey'] != null) {
            queryParameters['api_key'] = requestParameters['apiKey'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['sample'] != null) {
            queryParameters['sample'] = requestParameters['sample'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['seed'] != null) {
            queryParameters['seed'] = requestParameters['seed'];
        }

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/funders`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FundersArrayFromJSON(jsonValue));
    }

    /**
     * 
     * /funders
     */
    async getFunders(requestParameters: GetFundersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FundersArray> {
        const response = await this.getFundersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /institutions/{id}
     */
    async getInstitutionRaw(requestParameters: GetInstitutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Institution>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getInstitution().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/institutions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InstitutionFromJSON(jsonValue));
    }

    /**
     * 
     * /institutions/{id}
     */
    async getInstitution(requestParameters: GetInstitutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Institution> {
        const response = await this.getInstitutionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /institutions
     */
    async getInstitutionsRaw(requestParameters: GetInstitutionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Institutions>> {
        const queryParameters: any = {};

        if (requestParameters['apiKey'] != null) {
            queryParameters['api_key'] = requestParameters['apiKey'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['sample'] != null) {
            queryParameters['sample'] = requestParameters['sample'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['seed'] != null) {
            queryParameters['seed'] = requestParameters['seed'];
        }

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/institutions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InstitutionsFromJSON(jsonValue));
    }

    /**
     * 
     * /institutions
     */
    async getInstitutions(requestParameters: GetInstitutionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Institutions> {
        const response = await this.getInstitutionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /people/{id}
     */
    async getPersonRaw(requestParameters: GetPersonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Person>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPerson().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/people/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PersonFromJSON(jsonValue));
    }

    /**
     * 
     * /people/{id}
     */
    async getPerson(requestParameters: GetPersonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Person> {
        const response = await this.getPersonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /publishers/{id}
     */
    async getPublisherRaw(requestParameters: GetPublisherRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Publisher>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPublisher().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/publishers/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublisherFromJSON(jsonValue));
    }

    /**
     * 
     * /publishers/{id}
     */
    async getPublisher(requestParameters: GetPublisherRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Publisher> {
        const response = await this.getPublisherRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /publishers
     */
    async getPublishersRaw(requestParameters: GetPublishersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Publishers>> {
        const queryParameters: any = {};

        if (requestParameters['apiKey'] != null) {
            queryParameters['api_key'] = requestParameters['apiKey'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['sample'] != null) {
            queryParameters['sample'] = requestParameters['sample'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['seed'] != null) {
            queryParameters['seed'] = requestParameters['seed'];
        }

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/publishers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublishersFromJSON(jsonValue));
    }

    /**
     * 
     * /publishers
     */
    async getPublishers(requestParameters: GetPublishersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Publishers> {
        const response = await this.getPublishersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a random author
     * Get Random Author
     */
    async getRandomAuthorRaw(requestParameters: GetRandomAuthorRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Author>> {
        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/authors/random`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorFromJSON(jsonValue));
    }

    /**
     * Get a random author
     * Get Random Author
     */
    async getRandomAuthor(requestParameters: GetRandomAuthorRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Author> {
        const response = await this.getRandomAuthorRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a random concept
     * /concepts/random
     */
    async getRandomConceptRaw(requestParameters: GetRandomConceptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Concept>> {
        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/concepts/random`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConceptFromJSON(jsonValue));
    }

    /**
     * Get a random concept
     * /concepts/random
     */
    async getRandomConcept(requestParameters: GetRandomConceptRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Concept> {
        const response = await this.getRandomConceptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a random funder
     * /funders/random
     */
    async getRandomFunderRaw(requestParameters: GetRandomFunderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Funder>> {
        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/funders/random`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FunderFromJSON(jsonValue));
    }

    /**
     * Get a random funder
     * /funders/random
     */
    async getRandomFunder(requestParameters: GetRandomFunderRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Funder> {
        const response = await this.getRandomFunderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a random institution
     * /institutions/random
     */
    async getRandomInstitutionRaw(requestParameters: GetRandomInstitutionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Institution>> {
        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/institutions/random`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InstitutionFromJSON(jsonValue));
    }

    /**
     * Get a random institution
     * /institutions/random
     */
    async getRandomInstitution(requestParameters: GetRandomInstitutionRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Institution> {
        const response = await this.getRandomInstitutionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a random publisher
     * /publishers/random
     */
    async getRandomPublisherRaw(requestParameters: GetRandomPublisherRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Publisher>> {
        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/publishers/random`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublisherFromJSON(jsonValue));
    }

    /**
     * Get a random publisher
     * /publishers/random
     */
    async getRandomPublisher(requestParameters: GetRandomPublisherRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Publisher> {
        const response = await this.getRandomPublisherRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a random source
     * /sources/random
     */
    async getRandomSourceRaw(requestParameters: GetRandomSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Source>> {
        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/sources/random`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SourceFromJSON(jsonValue));
    }

    /**
     * Get a random source
     * /sources/random
     */
    async getRandomSource(requestParameters: GetRandomSourceRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Source> {
        const response = await this.getRandomSourceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a random work
     * /works/random
     */
    async getRandomWorkRaw(requestParameters: GetRandomWorkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Work>> {
        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/works/random`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkFromJSON(jsonValue));
    }

    /**
     * Get a random work
     * /works/random
     */
    async getRandomWork(requestParameters: GetRandomWorkRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Work> {
        const response = await this.getRandomWorkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Root endpoint
     * Root
     */
    async getRootRaw(requestParameters: GetRootRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RootResponseSchema>> {
        const queryParameters: any = {};

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RootResponseSchemaFromJSON(jsonValue));
    }

    /**
     * Root endpoint
     * Root
     */
    async getRoot(requestParameters: GetRootRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RootResponseSchema> {
        const response = await this.getRootRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /sources/{id}
     */
    async getSourceRaw(requestParameters: GetSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Source>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getSource().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/sources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SourceFromJSON(jsonValue));
    }

    /**
     * 
     * /sources/{id}
     */
    async getSource(requestParameters: GetSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Source> {
        const response = await this.getSourceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /sources
     */
    async getSourcesRaw(requestParameters: GetSourcesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Sources>> {
        const queryParameters: any = {};

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/sources`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SourcesFromJSON(jsonValue));
    }

    /**
     * 
     * /sources
     */
    async getSources(requestParameters: GetSourcesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Sources> {
        const response = await this.getSourcesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /subfields/{id}
     */
    async getSubfieldByIdRaw(requestParameters: GetSubfieldByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Subfield>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getSubfieldById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/subfields/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubfieldFromJSON(jsonValue));
    }

    /**
     * 
     * /subfields/{id}
     */
    async getSubfieldById(requestParameters: GetSubfieldByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Subfield> {
        const response = await this.getSubfieldByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /topics/{id}
     */
    async getTopicByIdRaw(requestParameters: GetTopicByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getTopicById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/topics/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * 
     * /topics/{id}
     */
    async getTopicById(requestParameters: GetTopicByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Topic> {
        const response = await this.getTopicByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /topics
     */
    async getTopicsRaw(requestParameters: GetTopicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Topics>> {
        const queryParameters: any = {};

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['sample'] != null) {
            queryParameters['sample'] = requestParameters['sample'];
        }

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/topics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicsFromJSON(jsonValue));
    }

    /**
     * 
     * /topics
     */
    async getTopics(requestParameters: GetTopicsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Topics> {
        const response = await this.getTopicsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a single work by its id
     * /works/{id}
     */
    async getWorkRaw(requestParameters: GetWorkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Work>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getWork().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/works/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkFromJSON(jsonValue));
    }

    /**
     * Get a single work by its id
     * /works/{id}
     */
    async getWork(requestParameters: GetWorkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Work> {
        const response = await this.getWorkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /works/{id}/ngrams
     */
    async getWorkNgramsRaw(requestParameters: GetWorkNgramsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Ngrams>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getWorkNgrams().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/works/{id}/ngrams`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NgramsFromJSON(jsonValue));
    }

    /**
     * 
     * /works/{id}/ngrams
     */
    async getWorkNgrams(requestParameters: GetWorkNgramsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Ngrams> {
        const response = await this.getWorkNgramsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 
     * /works
     */
    async getWorksRaw(requestParameters: GetWorksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorksResponse>> {
        const queryParameters: any = {};

        if (requestParameters['apiKey'] != null) {
            queryParameters['api_key'] = requestParameters['apiKey'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['per_page'] = requestParameters['perPage'];
        }

        if (requestParameters['sample'] != null) {
            queryParameters['sample'] = requestParameters['sample'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['seed'] != null) {
            queryParameters['seed'] = requestParameters['seed'];
        }

        if (requestParameters['select'] != null) {
            queryParameters['select'] = requestParameters['select'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['mailto'] != null) {
            queryParameters['mailto'] = requestParameters['mailto'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['userAgent'] != null) {
            headerParameters['User-Agent'] = String(requestParameters['userAgent']);
        }

        const response = await this.request({
            path: `/works`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorksResponseFromJSON(jsonValue));
    }

    /**
     * 
     * /works
     */
    async getWorks(requestParameters: GetWorksRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorksResponse> {
        const response = await this.getWorksRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

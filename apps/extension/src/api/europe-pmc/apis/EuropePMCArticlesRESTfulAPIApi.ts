/* tslint:disable */
/* eslint-disable */
/**
 * Europe PMC Articles RESTful API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.9
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ArticleStatusSearchRequest,
} from '../models/index';
import {
    ArticleStatusSearchRequestFromJSON,
    ArticleStatusSearchRequestToJSON,
} from '../models/index';

export interface ArticleRequest {
    source: ArticleSourceEnum;
    id: string;
    resultType?: ArticleResultTypeEnum;
    format?: ArticleFormatEnum;
    callback?: string;
    email?: string;
}

export interface BookXMLRequest {
    id: string;
}

export interface CitationsRequest {
    id: string;
    source: CitationsSourceEnum;
    page?: number;
    pageSize?: number;
    format?: CitationsFormatEnum;
    callback?: string;
}

export interface DataLinksRequest {
    id: string;
    source: DataLinksSourceEnum;
    category?: DataLinksCategoryEnum;
    obtainedBy?: DataLinksObtainedByEnum;
    fromDate?: string;
    tags?: string;
    sectionLimit?: string;
    email?: string;
    ref?: string;
    format?: DataLinksFormatEnum;
}

export interface DatabaseLinksRequest {
    id: string;
    source: DatabaseLinksSourceEnum;
    database?: DatabaseLinksDatabaseEnum;
    page?: number;
    pageSize?: number;
    format?: DatabaseLinksFormatEnum;
    callback?: string;
}

export interface EvaluationsRequest {
    id: string;
    source: EvaluationsSourceEnum;
    format?: EvaluationsFormatEnum;
}

export interface FieldsRequest {
    format?: FieldsFormatEnum;
    callback?: string;
}

export interface FullTextXMLRequest {
    id: string;
}

export interface LabsLinksRequest {
    id: string;
    source: LabsLinksSourceEnum;
    providerIds?: Array<number>;
    page?: number;
    pageSize?: number;
    format?: LabsLinksFormatEnum;
    callback?: string;
}

export interface ProfileRequest {
    query: string;
    profiletype?: ProfileProfiletypeEnum;
    synonym?: ProfileSynonymEnum;
    format?: ProfileFormatEnum;
    callback?: string;
    email?: string;
}

export interface ReferencesRequest {
    id: string;
    source: ReferencesSourceEnum;
    page?: number;
    pageSize?: number;
    format?: ReferencesFormatEnum;
    callback?: string;
}

export interface SearchRequest {
    query: string;
    resultType?: SearchResultTypeEnum;
    synonym?: SearchSynonymEnum;
    cursorMark?: string;
    pageSize?: number;
    sort?: string;
    format?: SearchFormatEnum;
    callback?: string;
    email?: string;
}

export interface SearchPOSTRequest {
    query: string;
    resultType?: SearchPOSTResultTypeEnum;
    synonym?: SearchPOSTSynonymEnum;
    cursorMark?: string;
    pageSize?: number;
    sort?: string;
    format?: SearchPOSTFormatEnum;
    callback?: string;
    email?: string;
}

export interface StatusUpdateSearchRequest {
    format?: StatusUpdateSearchFormatEnum;
    body?: ArticleStatusSearchRequest;
}

export interface SupplementaryFilesRequest {
    id: string;
    includeInlineImage?: SupplementaryFilesIncludeInlineImageEnum;
}

/**
 * 
 */
export class EuropePMCArticlesRESTfulAPIApi extends runtime.BaseAPI {

    /**
     * This module adheres to the CORS standard of headers to enable javascript cross-domain search. <br/>Construct your URL for search requests as follows:<br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/rest/article/{source}/{id}<br/><br/>
     * Use this module to search our publication database with a specific source and its id. It aslo accepts resultType, format, callback, debug and email query parameters.
     */
    async articleRaw(requestParameters: ArticleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['source'] == null) {
            throw new runtime.RequiredError(
                'source',
                'Required parameter "source" was null or undefined when calling article().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling article().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['resultType'] != null) {
            queryParameters['resultType'] = requestParameters['resultType'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['callback'] != null) {
            queryParameters['callback'] = requestParameters['callback'];
        }

        if (requestParameters['email'] != null) {
            queryParameters['email'] = requestParameters['email'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/article/{source}/{id}`.replace(`{${"source"}}`, encodeURIComponent(String(requestParameters['source']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This module adheres to the CORS standard of headers to enable javascript cross-domain search. <br/>Construct your URL for search requests as follows:<br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/rest/article/{source}/{id}<br/><br/>
     * Use this module to search our publication database with a specific source and its id. It aslo accepts resultType, format, callback, debug and email query parameters.
     */
    async article(requestParameters: ArticleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.articleRaw(requestParameters, initOverrides);
    }

    /**
     * Use this module to retrieve book XML formatted full text for the Open Access subset of the Europe PMC bookshelf.
     */
    async bookXMLRaw(requestParameters: BookXMLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling bookXML().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{id}/bookXML`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use this module to retrieve book XML formatted full text for the Open Access subset of the Europe PMC bookshelf.
     */
    async bookXML(requestParameters: BookXMLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bookXMLRaw(requestParameters, initOverrides);
    }

    /**
     * Use this module to retrieve a count and list of publications which cite a given publication.
     */
    async citationsRaw(requestParameters: CitationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling citations().'
            );
        }

        if (requestParameters['source'] == null) {
            throw new runtime.RequiredError(
                'source',
                'Required parameter "source" was null or undefined when calling citations().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['callback'] != null) {
            queryParameters['callback'] = requestParameters['callback'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{source}/{id}/citations`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters['source']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use this module to retrieve a count and list of publications which cite a given publication.
     */
    async citations(requestParameters: CitationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.citationsRaw(requestParameters, initOverrides);
    }

    /**
     * Details about the Scholix format can be found <a target=\"_blank\" href=\"http://www.scholix.org/schema\">here</a>
     * Use this module to retrieve data-literature links of the API modules databaseLinks, labsLinks and textMinedTerms consolidated in one web service module and returns them in Scholix format.
     */
    async dataLinksRaw(requestParameters: DataLinksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling dataLinks().'
            );
        }

        if (requestParameters['source'] == null) {
            throw new runtime.RequiredError(
                'source',
                'Required parameter "source" was null or undefined when calling dataLinks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        if (requestParameters['obtainedBy'] != null) {
            queryParameters['obtainedBy'] = requestParameters['obtainedBy'];
        }

        if (requestParameters['fromDate'] != null) {
            queryParameters['fromDate'] = requestParameters['fromDate'];
        }

        if (requestParameters['tags'] != null) {
            queryParameters['tags'] = requestParameters['tags'];
        }

        if (requestParameters['sectionLimit'] != null) {
            queryParameters['sectionLimit'] = requestParameters['sectionLimit'];
        }

        if (requestParameters['email'] != null) {
            queryParameters['email'] = requestParameters['email'];
        }

        if (requestParameters['ref'] != null) {
            queryParameters['ref'] = requestParameters['ref'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{source}/{id}/datalinks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters['source']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Details about the Scholix format can be found <a target=\"_blank\" href=\"http://www.scholix.org/schema\">here</a>
     * Use this module to retrieve data-literature links of the API modules databaseLinks, labsLinks and textMinedTerms consolidated in one web service module and returns them in Scholix format.
     */
    async dataLinks(requestParameters: DataLinksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.dataLinksRaw(requestParameters, initOverrides);
    }

    /**
     * Use this module to retrieve a count and list of biological database records that have cited a given publication (cross references).
     */
    async databaseLinksRaw(requestParameters: DatabaseLinksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling databaseLinks().'
            );
        }

        if (requestParameters['source'] == null) {
            throw new runtime.RequiredError(
                'source',
                'Required parameter "source" was null or undefined when calling databaseLinks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['database'] != null) {
            queryParameters['database'] = requestParameters['database'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['callback'] != null) {
            queryParameters['callback'] = requestParameters['callback'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{source}/{id}/databaseLinks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters['source']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use this module to retrieve a count and list of biological database records that have cited a given publication (cross references).
     */
    async databaseLinks(requestParameters: DatabaseLinksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.databaseLinksRaw(requestParameters, initOverrides);
    }

    /**
     * Use this module to retrieve evaluations for a given publication.
     */
    async evaluationsRaw(requestParameters: EvaluationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling evaluations().'
            );
        }

        if (requestParameters['source'] == null) {
            throw new runtime.RequiredError(
                'source',
                'Required parameter "source" was null or undefined when calling evaluations().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/evaluations/{source}/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters['source']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use this module to retrieve evaluations for a given publication.
     */
    async evaluations(requestParameters: EvaluationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.evaluationsRaw(requestParameters, initOverrides);
    }

    /**
     * A note is made above in the <a href=\"/RestfulWebService#oview\" target=\"_blank\">Overview</a> about the different versions of the web service available. Construct your URL for a fields request as follows for the production version:<br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/rest/fields <br/><br/>Construct your URL for a fields request as follows for the test version of the web service:<br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/test/rest/fields.
     * Use this module to see a full list of our indexed search fields, along with the datasets they can be used for.
     */
    async fieldsRaw(requestParameters: FieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['callback'] != null) {
            queryParameters['callback'] = requestParameters['callback'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/fields`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * A note is made above in the <a href=\"/RestfulWebService#oview\" target=\"_blank\">Overview</a> about the different versions of the web service available. Construct your URL for a fields request as follows for the production version:<br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/rest/fields <br/><br/>Construct your URL for a fields request as follows for the test version of the web service:<br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/test/rest/fields.
     * Use this module to see a full list of our indexed search fields, along with the datasets they can be used for.
     */
    async fields(requestParameters: FieldsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.fieldsRaw(requestParameters, initOverrides);
    }

    /**
     * Use this module to retrieve the full text in XML format for the Open Access subset of our full text publications.
     */
    async fullTextXMLRaw(requestParameters: FullTextXMLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling fullTextXML().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{id}/fullTextXML`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use this module to retrieve the full text in XML format for the Open Access subset of our full text publications.
     */
    async fullTextXML(requestParameters: FullTextXMLRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.fullTextXMLRaw(requestParameters, initOverrides);
    }

    /**
     * This module gives access to the External Links provided by 3rd parties (to extend Europe PMC content). See the Europe PMC External Links Service page for more details. Use this module to return the External Links for a given source (src) and identifier (ext_id) combination, or by the external content provider (providerId).
     */
    async labsLinksRaw(requestParameters: LabsLinksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling labsLinks().'
            );
        }

        if (requestParameters['source'] == null) {
            throw new runtime.RequiredError(
                'source',
                'Required parameter "source" was null or undefined when calling labsLinks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['providerIds'] != null) {
            queryParameters['providerIds'] = requestParameters['providerIds'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['callback'] != null) {
            queryParameters['callback'] = requestParameters['callback'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{source}/{id}/labsLinks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters['source']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This module gives access to the External Links provided by 3rd parties (to extend Europe PMC content). See the Europe PMC External Links Service page for more details. Use this module to return the External Links for a given source (src) and identifier (ext_id) combination, or by the external content provider (providerId).
     */
    async labsLinks(requestParameters: LabsLinksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.labsLinksRaw(requestParameters, initOverrides);
    }

    /**
     */
    async metricsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/metrics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async metrics(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.metricsRaw(initOverrides);
        return await response.value();
    }

    /**
     * This module adheres to the CORS standard of headers to enable javascript cross-domain search. <br/>Construct your URL for profile requests as follows:<br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/rest/profile?query=parameters<br/><br/>Note that for this module, the user may specify either a slash symbol (/) or a question mark symbol (?) after the method name, and before the query.For example: profile?query=parameters or profile/query=parameters
     * Use this module to obtain a \'profile\' of hit counts from our database for various publication types and data sources.
     */
    async profileRaw(requestParameters: ProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling profile().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['profiletype'] != null) {
            queryParameters['profiletype'] = requestParameters['profiletype'];
        }

        if (requestParameters['synonym'] != null) {
            queryParameters['synonym'] = requestParameters['synonym'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['callback'] != null) {
            queryParameters['callback'] = requestParameters['callback'];
        }

        if (requestParameters['email'] != null) {
            queryParameters['email'] = requestParameters['email'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/profile`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This module adheres to the CORS standard of headers to enable javascript cross-domain search. <br/>Construct your URL for profile requests as follows:<br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/rest/profile?query=parameters<br/><br/>Note that for this module, the user may specify either a slash symbol (/) or a question mark symbol (?) after the method name, and before the query.For example: profile?query=parameters or profile/query=parameters
     * Use this module to obtain a \'profile\' of hit counts from our database for various publication types and data sources.
     */
    async profile(requestParameters: ProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.profileRaw(requestParameters, initOverrides);
    }

    /**
     * Use this module to retrieve a count and list of publications referenced in a given publication.
     */
    async referencesRaw(requestParameters: ReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling references().'
            );
        }

        if (requestParameters['source'] == null) {
            throw new runtime.RequiredError(
                'source',
                'Required parameter "source" was null or undefined when calling references().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['callback'] != null) {
            queryParameters['callback'] = requestParameters['callback'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{source}/{id}/references`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters['source']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use this module to retrieve a count and list of publications referenced in a given publication.
     */
    async references(requestParameters: ReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.referencesRaw(requestParameters, initOverrides);
    }

    /**
     * This module adheres to the CORS standard of headers to enable javascript cross-domain search.Construct your URL for search requests as follows: <br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/rest/search?query=parameters <br/><br/>Note that for this module, the user may specify either a slash symbol (/) or a question mark symbol (?) after the method name, and before the query. For example:search?query=parameters or search/query=parameters
     * Use this module to search our publication database. For more information on query syntax, search field combination and other curiosities, see the Europe PMC help page
     */
    async searchRaw(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.JSONApiResponse<unknown>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling search().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['resultType'] != null) {
            queryParameters['resultType'] = requestParameters['resultType'];
        }

        if (requestParameters['synonym'] != null) {
            queryParameters['synonym'] = requestParameters['synonym'];
        }

        if (requestParameters['cursorMark'] != null) {
            queryParameters['cursorMark'] = requestParameters['cursorMark'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['callback'] != null) {
            queryParameters['callback'] = requestParameters['callback'];
        }

        if (requestParameters['email'] != null) {
            queryParameters['email'] = requestParameters['email'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);

    }

    /**
     * This module adheres to the CORS standard of headers to enable javascript cross-domain search.Construct your URL for search requests as follows: <br/><br/>GET https://www.ebi.ac.uk/europepmc/webservices/rest/search?query=parameters <br/><br/>Note that for this module, the user may specify either a slash symbol (/) or a question mark symbol (?) after the method name, and before the query. For example:search?query=parameters or search/query=parameters
     * Use this module to search our publication database. For more information on query syntax, search field combination and other curiosities, see the Europe PMC help page
     */
    async search(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<unknown> {
       const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This module must be used with the header Content-type:application/x-www-form-urlencoded.<br/>This means that all the parameters must be passed in the request body in the url encoded form. Construct your POST search requests as follows:<br/><br/>POST https://www.ebi.ac.uk/europepmc/webservices/rest/searchPOST with request body query=cancer&resultType=core&pageSize=10 
     * Use this module to search our publication database. For more information on query syntax, search field combination and other curiosities, see the Europe PMC help page
     */
    async searchPOSTRaw(requestParameters: SearchPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling searchPOST().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['query'] != null) {
            formParams.append('query', requestParameters['query'] as any);
        }

        if (requestParameters['resultType'] != null) {
            formParams.append('resultType', requestParameters['resultType'] as any);
        }

        if (requestParameters['synonym'] != null) {
            formParams.append('synonym', requestParameters['synonym'] as any);
        }

        if (requestParameters['cursorMark'] != null) {
            formParams.append('cursorMark', requestParameters['cursorMark'] as any);
        }

        if (requestParameters['pageSize'] != null) {
            formParams.append('pageSize', requestParameters['pageSize'] as any);
        }

        if (requestParameters['sort'] != null) {
            formParams.append('sort', requestParameters['sort'] as any);
        }

        if (requestParameters['format'] != null) {
            formParams.append('format', requestParameters['format'] as any);
        }

        if (requestParameters['callback'] != null) {
            formParams.append('callback', requestParameters['callback'] as any);
        }

        if (requestParameters['email'] != null) {
            formParams.append('email', requestParameters['email'] as any);
        }

        const response = await this.request({
            path: `/searchPOST`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This module must be used with the header Content-type:application/x-www-form-urlencoded.<br/>This means that all the parameters must be passed in the request body in the url encoded form. Construct your POST search requests as follows:<br/><br/>POST https://www.ebi.ac.uk/europepmc/webservices/rest/searchPOST with request body query=cancer&resultType=core&pageSize=10 
     * Use this module to search our publication database. For more information on query syntax, search field combination and other curiosities, see the Europe PMC help page
     */
    async searchPOST(requestParameters: SearchPOSTRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
      await this.searchPOSTRaw(requestParameters, initOverrides);
    }

    /**
     * This module must be used with the header Content-type:application/json.<br/>This means that all the parameters must be passed in the request body as a JSON object.<br/>Find out more <a href=\"https://europepmc.org/AboutArticleStatusMonitor\">About the article status monitor</a>, how updates are obtained and what’s included in the data.<br/>Construct your POST search requests as follows:<br/><br/>POST https://www.ebi.ac.uk/europepmc/webservices/rest/status-update-search with request body {  ids: [    {      src: string,      extId: string    }  ]}
     * Use this module to search for article status update
     */
    async statusUpdateSearchRaw(requestParameters: StatusUpdateSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/status-update-search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ArticleStatusSearchRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This module must be used with the header Content-type:application/json.<br/>This means that all the parameters must be passed in the request body as a JSON object.<br/>Find out more <a href=\"https://europepmc.org/AboutArticleStatusMonitor\">About the article status monitor</a>, how updates are obtained and what’s included in the data.<br/>Construct your POST search requests as follows:<br/><br/>POST https://www.ebi.ac.uk/europepmc/webservices/rest/status-update-search with request body {  ids: [    {      src: string,      extId: string    }  ]}
     * Use this module to search for article status update
     */
    async statusUpdateSearch(requestParameters: StatusUpdateSearchRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.statusUpdateSearchRaw(requestParameters, initOverrides);
    }

    /**
     * Use this module to retrieve supplementary files where we have these for our full text. The files will automatically download in zip format. Note that all supplementary files can be retrieved with the exception of non-Open Access images.
     */
    async supplementaryFilesRaw(requestParameters: SupplementaryFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling supplementaryFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['includeInlineImage'] != null) {
            queryParameters['includeInlineImage'] = requestParameters['includeInlineImage'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{id}/supplementaryFiles`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Use this module to retrieve supplementary files where we have these for our full text. The files will automatically download in zip format. Note that all supplementary files can be retrieved with the exception of non-Open Access images.
     */
    async supplementaryFiles(requestParameters: SupplementaryFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.supplementaryFilesRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ArticleSourceEnum = {
    Agr: 'AGR',
    Cba: 'CBA',
    Cit: 'CIT',
    Ctx: 'CTX',
    Eth: 'ETH',
    Hir: 'HIR',
    Med: 'MED',
    Nbk: 'NBK',
    Pat: 'PAT',
    Pmc: 'PMC',
    Ppr: 'PPR'
} as const;
export type ArticleSourceEnum = typeof ArticleSourceEnum[keyof typeof ArticleSourceEnum];
/**
 * @export
 */
export const ArticleResultTypeEnum = {
    Idlist: 'idlist',
    Lite: 'lite',
    Core: 'core'
} as const;
export type ArticleResultTypeEnum = typeof ArticleResultTypeEnum[keyof typeof ArticleResultTypeEnum];
/**
 * @export
 */
export const ArticleFormatEnum = {
    Xml: 'xml',
    Json: 'json',
    Dc: 'dc'
} as const;
export type ArticleFormatEnum = typeof ArticleFormatEnum[keyof typeof ArticleFormatEnum];
/**
 * @export
 */
export const CitationsSourceEnum = {
    Agr: 'AGR',
    Cba: 'CBA',
    Ctx: 'CTX',
    Eth: 'ETH',
    Hir: 'HIR',
    Med: 'MED',
    Hir2: 'HIR',
    Pat: 'PAT',
    Pmc: 'PMC',
    Ppr: 'PPR'
} as const;
export type CitationsSourceEnum = typeof CitationsSourceEnum[keyof typeof CitationsSourceEnum];
/**
 * @export
 */
export const CitationsFormatEnum = {
    Xml: 'xml',
    Json: 'json'
} as const;
export type CitationsFormatEnum = typeof CitationsFormatEnum[keyof typeof CitationsFormatEnum];
/**
 * @export
 */
export const DataLinksSourceEnum = {
    Agr: 'AGR',
    Cba: 'CBA',
    Ctx: 'CTX',
    Eth: 'ETH',
    Hir: 'HIR',
    Med: 'MED',
    Hir2: 'HIR',
    Pat: 'PAT',
    Pmc: 'PMC',
    Ppr: 'PPR'
} as const;
export type DataLinksSourceEnum = typeof DataLinksSourceEnum[keyof typeof DataLinksSourceEnum];
/**
 * @export
 */
export const DataLinksCategoryEnum = {
    AccessToUnderstanding: 'Access to Understanding',
    Altmetric: 'Altmetric',
    ArthritisResearchUk: 'Arthritis Research UK',
    BibliomicsAndTextMiningGroupBiTeM: 'Bibliomics and Text Mining Group (BiTeM)',
    BioModels: 'BioModels',
    BioSamples: 'BioSamples',
    BioStudies: 'BioStudies',
    Cellosaurus: 'Cellosaurus',
    CentreForReviewsAndDisseminationUk: 'Centre for Reviews and Dissemination (UK)',
    Chemicals: 'Chemicals',
    ClinicalTrials: 'Clinical Trials',
    Cosmic: 'COSMIC',
    DataCitations: 'Data Citations',
    Depod: 'DEPOD',
    Diseases: 'Diseases',
    DisGeNet: 'DisGeNET',
    DisProt: 'DisProt',
    DryadDigitalRepository: 'Dryad Digital Repository',
    EbiMetagenomics: 'EBI Metagenomics',
    EbiTrainOnline: 'EBI Train Online',
    ElectronMicroscopyDataBank: 'Electron Microscopy Data Bank',
    EmblPressReleases: 'EMBL Press Releases',
    Empiar: 'EMPIAR',
    EncodeEncyclopediaOfDnaElements: 'ENCODE: Encyclopedia of DNA Elements',
    EuroFirDocumentRepository: 'EuroFIR Document Repository',
    EuropeanGenomePhenomeArchive: 'European Genome-Phenome Archive',
    F1000Prime: 'F1000Prime',
    FlyBase: 'FlyBase',
    FunctionalGenomicsExperiments: 'Functional Genomics Experiments',
    GeneOntologyGoTerms: 'Gene Ontology (GO) Terms',
    GenesProteins: 'Genes & Proteins',
    GenomeRnai: 'GenomeRNAi',
    GoaProject: 'GOA Project',
    HalOpenArchive: 'HAL Open Archive',
    IntAct: 'IntAct',
    IPtMnet: 'iPTMnet',
    IupharBpsGuideToPharmacology: 'IUPHAR/BPS Guide to Pharmacology',
    Kudos: 'Kudos',
    LinkpingUniversityDigitalArchive: 'Linköping University Digital Archive',
    MarieCuriePressReleases: 'Marie Curie Press Releases',
    MedicalResearchCouncil: 'Medical Research Council',
    MetaboLights: 'MetaboLights',
    MGnify: 'MGnify',
    ModelArchive: 'ModelArchive',
    MouseGenomeInformaticsMgi: 'Mouse Genome Informatics (MGI)',
    NationalCentreForTextMiningNaCteM: 'National Centre for Text Mining (NaCTeM)',
    NeuroscienceInformationFramework: 'Neuroscience Information Framework',
    NhgriEbiGwasCatalog: 'NHGRI-EBI GWAS Catalog',
    NtnuBsc: 'NTNU/BSC',
    NucleotideSequences: 'Nucleotide Sequences',
    OpenAccessAtBielefeldUniversity: 'Open Access at Bielefeld University',
    OpenAccessAtLundUniversity: 'Open Access at Lund University',
    OpenTargetsPlatform: 'Open Targets Platform',
    OpenAire: 'OpenAIRE',
    Pangaea: 'PANGAEA',
    Pfam: 'Pfam',
    PhenoMiner: 'PhenoMiner',
    PomBase: 'PomBase\\',
    UniversityOfCambridge: 'University of Cambridge',
    PreLights: 'preLights',
    ProteinFamilies: 'Protein Families',
    ProteinInteractions: 'Protein Interactions',
    ProteinStructures: 'Protein Structures',
    ProteomeXchange: 'ProteomeXchange',
    ProteomicsData: 'Proteomics Data',
    ProtocolsIo: 'protocols.io',
    Publons: 'Publons',
    PubTatorNcbi: 'PubTator (NCBI)',
    Reactome: 'Reactome',
    RelatedImmuneEpitopeInformationImmuneEpitopeDatabaseAndAnalysisResource: 'Related Immune Epitope Information - Immune Epitope Database and Analysis Resource',
    ReuseRecipeDocument: 'Reuse Recipe Document',
    SabioRk: 'SABIO-RK',
    SaccharomycesGenomeDatabase: 'Saccharomyces Genome Database',
    Signor: 'SIGNOR',
    StorreUniversityOfStirlingRepository: 'STORRE: University of Stirling repository',
    StrendaDb: 'STRENDA DB',
    VersusArthritis: 'Versus Arthritis',
    WellcomeTrust: 'Wellcome Trust',
    WikiPathways: 'WikiPathways',
    Wikipedia: 'Wikipedia',
    WorldwideCancerResearch: 'Worldwide Cancer Research',
    WormBase: 'WormBase',
    Ximbio: 'Ximbio',
    Zfin: 'ZFIN'
} as const;
export type DataLinksCategoryEnum = typeof DataLinksCategoryEnum[keyof typeof DataLinksCategoryEnum];
/**
 * @export
 */
export const DataLinksObtainedByEnum = {
    TmAccession: 'tm_accession',
    TmTerm: 'tm_term',
    ExtLinks: 'ext_links',
    Submission: 'submission'
} as const;
export type DataLinksObtainedByEnum = typeof DataLinksObtainedByEnum[keyof typeof DataLinksObtainedByEnum];
/**
 * @export
 */
export const DataLinksFormatEnum = {
    Xml: 'xml',
    Json: 'json'
} as const;
export type DataLinksFormatEnum = typeof DataLinksFormatEnum[keyof typeof DataLinksFormatEnum];
/**
 * @export
 */
export const DatabaseLinksSourceEnum = {
    Agr: 'AGR',
    Cba: 'CBA',
    Ctx: 'CTX',
    Eth: 'ETH',
    Hir: 'HIR',
    Med: 'MED',
    Hir2: 'HIR',
    Pat: 'PAT',
    Pmc: 'PMC',
    Ppr: 'PPR'
} as const;
export type DatabaseLinksSourceEnum = typeof DatabaseLinksSourceEnum[keyof typeof DatabaseLinksSourceEnum];
/**
 * @export
 */
export const DatabaseLinksDatabaseEnum = {
    Arxpr: 'ARXPR',
    Chebi: 'CHEBI',
    Chembl: 'CHEMBL',
    Embl: 'EMBL',
    Intact: 'INTACT',
    Interpro: 'INTERPRO',
    Omim: 'OMIM',
    Pdb: 'PDB',
    Pride: 'PRIDE',
    Uniprot: 'UNIPROT'
} as const;
export type DatabaseLinksDatabaseEnum = typeof DatabaseLinksDatabaseEnum[keyof typeof DatabaseLinksDatabaseEnum];
/**
 * @export
 */
export const DatabaseLinksFormatEnum = {
    Xml: 'xml',
    Json: 'json'
} as const;
export type DatabaseLinksFormatEnum = typeof DatabaseLinksFormatEnum[keyof typeof DatabaseLinksFormatEnum];
/**
 * @export
 */
export const EvaluationsSourceEnum = {
    Agr: 'AGR',
    Cba: 'CBA',
    Ctx: 'CTX',
    Eth: 'ETH',
    Hir: 'HIR',
    Med: 'MED',
    Hir2: 'HIR',
    Pat: 'PAT',
    Pmc: 'PMC',
    Ppr: 'PPR'
} as const;
export type EvaluationsSourceEnum = typeof EvaluationsSourceEnum[keyof typeof EvaluationsSourceEnum];
/**
 * @export
 */
export const EvaluationsFormatEnum = {
    Xml: 'xml',
    Json: 'json'
} as const;
export type EvaluationsFormatEnum = typeof EvaluationsFormatEnum[keyof typeof EvaluationsFormatEnum];
/**
 * @export
 */
export const FieldsFormatEnum = {
    Xml: 'xml',
    Json: 'json'
} as const;
export type FieldsFormatEnum = typeof FieldsFormatEnum[keyof typeof FieldsFormatEnum];
/**
 * @export
 */
export const LabsLinksSourceEnum = {
    Agr: 'AGR',
    Cba: 'CBA',
    Ctx: 'CTX',
    Eth: 'ETH',
    Hir: 'HIR',
    Med: 'MED',
    Hir2: 'HIR',
    Pat: 'PAT',
    Pmc: 'PMC',
    Ppr: 'PPR'
} as const;
export type LabsLinksSourceEnum = typeof LabsLinksSourceEnum[keyof typeof LabsLinksSourceEnum];
/**
 * @export
 */
export const LabsLinksFormatEnum = {
    Xml: 'xml',
    Json: 'json'
} as const;
export type LabsLinksFormatEnum = typeof LabsLinksFormatEnum[keyof typeof LabsLinksFormatEnum];
/**
 * @export
 */
export const ProfileProfiletypeEnum = {
    PubType: 'pub_type',
    Source: 'source',
    All: 'all'
} as const;
export type ProfileProfiletypeEnum = typeof ProfileProfiletypeEnum[keyof typeof ProfileProfiletypeEnum];
/**
 * @export
 */
export const ProfileSynonymEnum = {
    True: 'TRUE',
    Y: 'Y',
    Yes: 'YES',
    False: 'FALSE',
    N: 'N',
    No: 'NO'
} as const;
export type ProfileSynonymEnum = typeof ProfileSynonymEnum[keyof typeof ProfileSynonymEnum];
/**
 * @export
 */
export const ProfileFormatEnum = {
    Xml: 'xml',
    Json: 'json'
} as const;
export type ProfileFormatEnum = typeof ProfileFormatEnum[keyof typeof ProfileFormatEnum];
/**
 * @export
 */
export const ReferencesSourceEnum = {
    Agr: 'AGR',
    Cba: 'CBA',
    Ctx: 'CTX',
    Eth: 'ETH',
    Hir: 'HIR',
    Med: 'MED',
    Hir2: 'HIR',
    Pat: 'PAT',
    Pmc: 'PMC',
    Ppr: 'PPR'
} as const;
export type ReferencesSourceEnum = typeof ReferencesSourceEnum[keyof typeof ReferencesSourceEnum];
/**
 * @export
 */
export const ReferencesFormatEnum = {
    Xml: 'xml',
    Json: 'json'
} as const;
export type ReferencesFormatEnum = typeof ReferencesFormatEnum[keyof typeof ReferencesFormatEnum];
/**
 * @export
 */
export const SearchResultTypeEnum = {
    Idlist: 'idlist',
    Lite: 'lite',
    Core: 'core'
} as const;
export type SearchResultTypeEnum = typeof SearchResultTypeEnum[keyof typeof SearchResultTypeEnum];
/**
 * @export
 */
export const SearchSynonymEnum = {
    True: 'TRUE',
    Y: 'Y',
    Yes: 'YES',
    False: 'FALSE',
    N: 'N',
    No: 'NO'
} as const;
export type SearchSynonymEnum = typeof SearchSynonymEnum[keyof typeof SearchSynonymEnum];
/**
 * @export
 */
export const SearchFormatEnum = {
    Xml: 'xml',
    Json: 'json',
    Dc: 'dc'
} as const;
export type SearchFormatEnum = typeof SearchFormatEnum[keyof typeof SearchFormatEnum];
/**
 * @export
 */
export const SearchPOSTResultTypeEnum = {
    Idlist: 'idlist',
    Lite: 'lite',
    Core: 'core'
} as const;
export type SearchPOSTResultTypeEnum = typeof SearchPOSTResultTypeEnum[keyof typeof SearchPOSTResultTypeEnum];
/**
 * @export
 */
export const SearchPOSTSynonymEnum = {
    True: 'TRUE',
    Y: 'Y',
    Yes: 'YES',
    False: 'FALSE',
    N: 'N',
    No: 'NO'
} as const;
export type SearchPOSTSynonymEnum = typeof SearchPOSTSynonymEnum[keyof typeof SearchPOSTSynonymEnum];
/**
 * @export
 */
export const SearchPOSTFormatEnum = {
    Xml: 'xml',
    Json: 'json',
    Dc: 'dc'
} as const;
export type SearchPOSTFormatEnum = typeof SearchPOSTFormatEnum[keyof typeof SearchPOSTFormatEnum];
/**
 * @export
 */
export const StatusUpdateSearchFormatEnum = {
    Xml: 'xml',
    Json: 'json'
} as const;
export type StatusUpdateSearchFormatEnum = typeof StatusUpdateSearchFormatEnum[keyof typeof StatusUpdateSearchFormatEnum];
/**
 * @export
 */
export const SupplementaryFilesIncludeInlineImageEnum = {
    Y: 'y',
    Yes: 'yes',
    True: 'true',
    N: 'n',
    No: 'no',
    False: 'false'
} as const;
export type SupplementaryFilesIncludeInlineImageEnum = typeof SupplementaryFilesIncludeInlineImageEnum[keyof typeof SupplementaryFilesIncludeInlineImageEnum];
